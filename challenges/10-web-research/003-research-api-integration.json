{
  "id": "10-003",
  "module": "web-research",
  "title": "Research API Integration",
  "description": "Learn the research-to-code pipeline: find API documentation using web tools, understand the API structure, and create a well-typed client with proper error handling.",
  "difficulty": "intermediate",
  "xpReward": 225,
  "estimatedMinutes": 15,
  "skills": ["api-research", "api-integration", "client-design", "error-handling"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-10-003",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Research API Integration\n\nLearn the systematic process of researching an unfamiliar API and\ntranslating documentation into working, well-structured client code.\n\n---\n\n## The Research-to-Code Pipeline\n\nWhen you need to integrate with an external API you have never used\nbefore, there is a proven research workflow:\n\n```\n1. Find the docs    --> WebSearch for \"[service] API documentation\"\n2. Read the docs    --> WebFetch the documentation page\n3. Understand structure --> Base URL, auth, endpoints, rate limits\n4. Plan the client  --> Map endpoints to functions, design types\n5. Write the code   --> Client wrapper with error handling\n6. Test it          --> curl commands or simple test scripts\n```\n\nSkipping steps leads to fragile integrations. Taking them in order\nleads to clean, maintainable API clients.\n\n## Step 1: Finding API Documentation\n\nUse WebSearch to locate official documentation:\n```\nquery: \"GitHub REST API documentation 2026\"\nallowed_domains: [\"docs.github.com\", \"github.com\"]\n```\n\nLook for:\n- **Official docs** (always prefer these)\n- **API reference** (endpoint listings with request/response schemas)\n- **Getting started guides** (quick overview of auth and basic calls)\n- **Changelogs** (recent breaking changes)\n\n## Step 2: Reading API Documentation\n\nOnce you have a URL, use WebFetch with a targeted prompt:\n```\nurl: \"https://docs.github.com/en/rest\"\nprompt: \"Extract: base URL, authentication methods, rate limits,\n         and list all endpoint categories with their paths.\"\n```\n\nFor large APIs, fetch multiple pages:\n- The overview page for base URL and auth\n- Specific endpoint pages for request/response details\n\n## Step 3: Understanding API Structure\n\nEvery REST API has these components. Document each one:\n\n| Component | What to Find | Example |\n|-----------|-------------|--------|\n| **Base URL** | Root URL for all requests | `https://api.github.com` |\n| **Authentication** | How to prove identity | Bearer token, API key, OAuth |\n| **Endpoints** | Available operations | `GET /repos/{owner}/{repo}` |\n| **Request format** | How to send data | JSON body, query params, headers |\n| **Response format** | What comes back | JSON schema, status codes |\n| **Rate limits** | How many requests allowed | 5000/hour for authenticated |\n| **Error codes** | How failures are reported | 404 Not Found, 422 Validation |\n| **Pagination** | How to get large datasets | Link headers, cursor-based |\n\n## Step 4: Planning the Client\n\nBefore writing code, plan your client's public interface:\n\n```javascript\n// Map each endpoint to a clear method name:\n// GET  /users/{id}         --> getUser(id)\n// POST /users              --> createUser(data)\n// GET  /users/{id}/posts   --> getUserPosts(userId)\n// GET  /posts?search=term  --> searchPosts(query)\n```\n\nDesign decisions to make:\n- **Constructor:** What config does the client need? (base URL, API key)\n- **Methods:** One method per endpoint or grouped by resource?\n- **Types:** What does each request/response look like?\n- **Errors:** Custom error class? Retry logic? Timeout?\n\n## Step 5: Writing the Client\n\nA well-structured API client has these layers:\n\n```\nPublic methods (getUser, createPost)\n       |\n    v\nRequest builder (adds auth, sets headers, builds URL)\n       |\n    v\nHTTP layer (fetch, error checking, response parsing)\n       |\n    v\nError handler (maps status codes to errors, retries)\n```\n\nKey patterns:\n- **Centralized request method:** One private method handles all HTTP\n  details so auth, headers, and error handling live in one place\n- **Type safety:** Define interfaces for request params and responses\n- **Error wrapping:** Convert HTTP errors to meaningful application errors\n- **Configuration:** Base URL, timeout, and auth passed to constructor\n\n## Step 6: Testing the API\n\nBefore trusting your client, test with curl:\n```bash\n# Test authentication\ncurl -H \"Authorization: Bearer $TOKEN\" https://api.example.com/me\n\n# Test a GET endpoint\ncurl https://api.example.com/posts/1\n\n# Test a POST endpoint\ncurl -X POST -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"test\"}' https://api.example.com/posts\n```\n\nThen verify your client matches curl's results.\n\n---\n\n## Your Task\n\nYou are building a weather dashboard application. You need to integrate\nwith the **OpenWeatherMap API** (a well-known free weather API) to fetch\ncurrent weather and forecasts.\n\n### Steps:\n1. Research the OpenWeatherMap API using WebSearch and WebFetch\n2. Create an integration plan documenting the API structure\n3. Implement a clean API client based on your research\n4. Include example curl commands for testing\n\n### What to Deliver:\n\n**api-plan.md** -- Your research and integration plan:\n- Base URL and authentication method\n- At least 3 endpoints with their paths and parameters\n- Response format for the main endpoint\n- Rate limits and pricing tier info\n- Error codes and what they mean\n\n**weatherClient.js** -- A working API client:\n- Constructor accepting API key configuration\n- Methods for at least 3 API operations\n- Centralized request method with error handling\n- Proper HTTP error checking (status codes)\n\n## Objectives\n1. Create api-plan.md with researched API documentation\n2. Document base URL, auth method, and at least 3 endpoints\n3. Create weatherClient.js with a clean client implementation\n4. Client has error handling for HTTP failures\n5. Client methods map to documented endpoints\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"weather-dashboard\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"description\": \"Weather dashboard needing API integration\",\n  \"scripts\": {\n    \"start\": \"node src/index.js\",\n    \"test\": \"node test/test-client.js\"\n  }\n}\n"
      },
      {
        "path": "src/index.js",
        "content": "// Weather Dashboard - Main Entry Point\n// TODO: Import and use the weather client after implementing it\n\nimport { config } from './config.js';\n\nconsole.log('Weather Dashboard');\nconsole.log('API integration not yet implemented');\nconsole.log('Research the OpenWeatherMap API and create weatherClient.js');\n"
      },
      {
        "path": "src/config.js",
        "content": "// Application configuration\n// The API key should come from environment variables in production\nexport const config = {\n  apiKey: process.env.OPENWEATHER_API_KEY || 'your-api-key-here',\n  defaultCity: 'London',\n  units: 'metric',  // 'metric', 'imperial', or 'standard'\n  language: 'en'\n};\n"
      },
      {
        "path": "src/dashboard.js",
        "content": "// Dashboard display logic\n// This module will format and display weather data\n// It expects data from the weather client\n\nexport function displayCurrentWeather(data) {\n  console.log(`\\n--- Current Weather ---`);\n  console.log(`Location: ${data.name}`);\n  console.log(`Temperature: ${data.temp}`);\n  console.log(`Conditions: ${data.description}`);\n  console.log(`Humidity: ${data.humidity}%`);\n}\n\nexport function displayForecast(data) {\n  console.log(`\\n--- 5-Day Forecast ---`);\n  for (const day of data.daily) {\n    console.log(`${day.date}: ${day.temp} - ${day.description}`);\n  }\n}\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create api-plan.md with researched API documentation",
      "type": "file_exists",
      "target": "api-plan.md",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Document base URL, authentication method, and at least 3 endpoints",
      "type": "file_contains",
      "target": "api-plan.md",
      "pattern": "api\\.openweathermap|[Bb]ase URL|appid|api_key|[Aa]uth|/weather|/forecast|/onecall|/geo|/air",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Create weatherClient.js with API client implementation",
      "type": "file_exists",
      "target": "weatherClient.js",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Client has error handling for HTTP failures",
      "type": "file_contains",
      "target": "weatherClient.js",
      "pattern": "catch|throw|Error|status|ok|response\\.ok|!.*ok|statusCode|error",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Client has methods that map to documented API endpoints",
      "type": "file_contains",
      "target": "weatherClient.js",
      "pattern": "getWeather|getCurrentWeather|getForecast|getByCity|fetchWeather|async.*weather|async.*forecast",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Client has a centralized request method that handles auth and base URL",
      "type": "file_contains",
      "target": "weatherClient.js",
      "pattern": "request|_fetch|_get|_post|baseUrl|baseURL|this\\.apiKey|this\\.key|#request|#fetch",
      "xpBonus": 50
    },
    {
      "id": "bonus-2",
      "description": "Include curl commands for testing the API in the plan",
      "type": "file_contains",
      "target": "api-plan.md",
      "pattern": "curl|[Tt]est.*command|[Ee]xample.*request|[Tt]esting",
      "xpBonus": 50
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Start by searching for 'OpenWeatherMap API documentation'. Then use WebFetch on the official docs page to extract the base URL, authentication method (API key via query parameter), and the main endpoints. Read the README for the full research-to-code pipeline.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "OpenWeatherMap uses api.openweathermap.org as its base URL and passes the API key as an 'appid' query parameter. Key endpoints include /data/2.5/weather (current), /data/2.5/forecast (5-day), and /geo/1.0/direct (geocoding). Build your client with a constructor that takes the API key and a private _request method.",
      "xpCost": 45
    },
    {
      "level": 3,
      "text": "Ask Claude: 'Research the OpenWeatherMap API using WebSearch and WebFetch. Create api-plan.md documenting: base URL (api.openweathermap.org), auth (appid query param), endpoints (current weather, forecast, geocoding), rate limits, error codes. Then create weatherClient.js with: constructor(apiKey), private _request(endpoint, params) method, getCurrentWeather(city), getForecast(city), and getCoordinates(city) methods. Include try/catch error handling and HTTP status checking.'",
      "xpCost": 90
    }
  ],

  "solution": {
    "approach": "Research the OpenWeatherMap API using WebSearch to find docs, WebFetch to read them, then follow the research-to-code pipeline: document the API structure in api-plan.md, and implement a clean client in weatherClient.js with a centralized request method and proper error handling.",
    "example": "WebSearch 'OpenWeatherMap API documentation', WebFetch the official docs, document base URL/auth/endpoints in api-plan.md, then create weatherClient.js with constructor(apiKey), _request(endpoint, params), getCurrentWeather(city), getForecast(city), getCoordinates(city).",
    "alternativeApproaches": [
      "Fetch the API docs page and the error codes page separately to get complete coverage",
      "Start with curl commands to test the API manually, then wrap each curl call in a client method",
      "Research a TypeScript approach and create weatherClient.ts with full type definitions"
    ]
  },

  "learningPoints": [
    "The research-to-code pipeline (find docs -> read docs -> understand structure -> plan client -> write code -> test) prevents fragile integrations",
    "Always document API structure before writing code: base URL, auth, endpoints, errors, rate limits",
    "A centralized request method keeps auth, headers, and error handling in one place instead of duplicated across every method",
    "Map each API endpoint to a clearly-named client method for a clean public interface",
    "Test API calls with curl first to understand the raw request/response before wrapping in code",
    "Error handling should convert HTTP status codes into meaningful application errors"
  ],

  "nextChallenge": "10-004"
}
