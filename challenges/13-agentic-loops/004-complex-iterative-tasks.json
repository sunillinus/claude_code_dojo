{
  "id": "13-004",
  "module": "agentic-loops",
  "title": "Complex Iterative Task",
  "description": "Use Ralph Loop to tackle a large-scale codebase cleanup — the kind of task where agentic loops really shine.\n\n## When Ralph Loop Shines\n\nRalph Loop is at its best with **large-scale, well-defined cleanup** tasks:\n- The same kind of fix needed across many files\n- Clear, measurable criteria for \"done\"\n- Mechanical changes that don't require creative judgment\n\nExamples: removing all debug logs from a project, adding error handling to every async function, or standardizing naming conventions across a codebase.\n\n## Anti-Patterns to Avoid\n\n- **Scope too broad**: \"Make the project production-ready\" — too vague, unmeasurable\n- **Unmeasurable promises**: \"Improve code quality\" — what does that mean?\n- **Conflicting changes**: \"Make code DRY and also self-contained\" — contradictory goals\n- **No verification step**: Always verify Ralph Loop's work when it finishes\n\n## The Verification Step\n\nAfter Ralph Loop completes, **always verify**:\n1. Read key files to spot-check the changes\n2. Run any available tests or linters\n3. Search for patterns that should have been eliminated\n4. Confirm nothing was broken by the changes\n\nTrust but verify. Ralph Loop is powerful but not infallible.\n\n## When to Cancel and Re-scope\n\nIf Ralph Loop is making the same mistake repeatedly or going in circles:\n- Cancel with `/ralph-loop:cancel-ralph`\n- Narrow the scope (fewer files, simpler criteria)\n- Re-run with a more focused prompt\n\n## Your Exercise\n\nThis workspace contains a **messy inventory API** with multiple categories of problems across 9 files. Your job: use Ralph Loop to bring the codebase up to standard.\n\n**Problems in the codebase:**\n- `console.log` debug statements left in handler files\n- TODO comments scattered across files (unimplemented features)\n- No error handling on any async function\n- No JSDoc documentation on any function\n- Inconsistent naming: some files use `snake_case` variables while others use `camelCase`\n\n**Your strategy:** Decide whether to use one big Ralph Loop or multiple phases. Then execute with `/ralph-loop:ralph-loop` and verify the results.\n\n**Suggested approach (multi-phase):**\n\nPhase 1 — Clean up:\n```\n/ralph-loop:ralph-loop \"Remove all console.log debug statements and all TODO comments from files in src/. Implement what each TODO asks for before removing it. When no file in src/ contains console.log or TODO, output <promise>CLEANUP_DONE</promise>.\" --completion-promise \"CLEANUP_DONE\" --max-iterations 15\n```\n\nPhase 2 — Standardize and harden:\n```\n/ralph-loop:ralph-loop \"Add try/catch error handling to every async function in src/handlers/. Add JSDoc with @param and @returns to every exported function in src/. Normalize all variable names to camelCase. When every async handler has try/catch, every exported function has JSDoc, and no snake_case variable names remain, output <promise>STANDARDIZE_DONE</promise>.\" --completion-promise \"STANDARDIZE_DONE\" --max-iterations 15\n```\n\n**Or try one big loop** if you're feeling confident:\n```\n/ralph-loop:ralph-loop \"Clean up this codebase: remove all console.log and TODO comments (implement TODOs first), add try/catch to all async functions, add JSDoc to all exported functions, normalize all variables to camelCase. When done, output <promise>ALL_CLEAN</promise>.\" --completion-promise \"ALL_CLEAN\" --max-iterations 25\n```\n\nAfter completion, verify the results and run `/dojo check`.",
  "difficulty": "advanced",
  "xpReward": 350,
  "estimatedMinutes": 25,
  "skills": ["complex-automation", "ralph-loop", "codebase-cleanup"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-13-004",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Inventory Management API\n\nREST API for managing inventory items, categories, suppliers, and orders.\n\n## Files\n\n- `src/index.js` — Server entry point and route setup\n- `src/handlers/items.js` — Item CRUD handlers\n- `src/handlers/categories.js` — Category handlers\n- `src/handlers/suppliers.js` — Supplier handlers\n- `src/handlers/orders.js` — Order handlers\n- `src/handlers/reports.js` — Report generation\n- `src/db.js` — Database connection\n- `src/middleware/auth.js` — Authentication middleware\n- `src/utils/helpers.js` — Utility functions\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"inventory-api\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"node src/index.js\"\n  }\n}\n"
      },
      {
        "path": "src/index.js",
        "content": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\nconst { getAllItems, getItem, createItem, updateItem, deleteItem } = require('./handlers/items');\nconst { getAllCategories, getCategory, createCategory } = require('./handlers/categories');\nconst { getAllSuppliers, getSupplier, createSupplier, updateSupplier } = require('./handlers/suppliers');\nconst { createOrder, getOrder, getOrdersByStatus, updateOrderStatus } = require('./handlers/orders');\nconst { getReport, getSummary } = require('./handlers/reports');\n\napp.get('/api/items', getAllItems);\napp.get('/api/items/:id', getItem);\napp.post('/api/items', createItem);\napp.put('/api/items/:id', updateItem);\napp.delete('/api/items/:id', deleteItem);\n\napp.get('/api/categories', getAllCategories);\napp.get('/api/categories/:id', getCategory);\napp.post('/api/categories', createCategory);\n\napp.get('/api/suppliers', getAllSuppliers);\napp.get('/api/suppliers/:id', getSupplier);\napp.post('/api/suppliers', createSupplier);\napp.put('/api/suppliers/:id', updateSupplier);\n\napp.post('/api/orders', createOrder);\napp.get('/api/orders/:id', getOrder);\napp.get('/api/orders/status/:status', getOrdersByStatus);\napp.patch('/api/orders/:id/status', updateOrderStatus);\n\napp.get('/api/reports/:type', getReport);\napp.get('/api/summary', getSummary);\n\nconsole.log('Setting up routes...');\napp.listen(3000);\n"
      },
      {
        "path": "src/handlers/items.js",
        "content": "const db = require('../db');\n\nasync function getAllItems(req, res) {\n  console.log('Fetching all items');\n  const items = await db.query('SELECT * FROM items');\n  res.json(items);\n}\n\nasync function getItem(req, res) {\n  var item_id = req.params.id;\n  console.log('Fetching item:', item_id);\n  const item = await db.query('SELECT * FROM items WHERE id = $1', [item_id]);\n  res.json(item);\n}\n\nasync function createItem(req, res) {\n  var item_name = req.body.name;\n  var item_price = req.body.price;\n  var item_quantity = req.body.quantity;\n  var category_id = req.body.categoryId;\n  var supplier_id = req.body.supplierId;\n  console.log('Creating item:', item_name);\n  const item = await db.query(\n    'INSERT INTO items (name, price, quantity, category_id, supplier_id) VALUES ($1, $2, $3, $4, $5) RETURNING *',\n    [item_name, item_price, item_quantity, category_id, supplier_id]\n  );\n  res.json(item);\n}\n\nasync function updateItem(req, res) {\n  var item_name = req.body.name;\n  var item_price = req.body.price;\n  var item_quantity = req.body.quantity;\n  console.log('Updating item:', req.params.id);\n  const item = await db.query(\n    'UPDATE items SET name = $1, price = $2, quantity = $3 WHERE id = $4 RETURNING *',\n    [item_name, item_price, item_quantity, req.params.id]\n  );\n  res.json(item);\n}\n\nasync function deleteItem(req, res) {\n  console.log('Deleting item:', req.params.id);\n  await db.query('DELETE FROM items WHERE id = $1', [req.params.id]);\n  res.status(204).end();\n}\n\nmodule.exports = { getAllItems, getItem, createItem, updateItem, deleteItem };\n"
      },
      {
        "path": "src/handlers/categories.js",
        "content": "const db = require('../db');\n\nasync function getAllCategories(req, res) {\n  console.log('Fetching categories');\n  const categories = await db.query('SELECT * FROM categories');\n  res.json(categories);\n}\n\nasync function getCategory(req, res) {\n  var cat_id = req.params.id;\n  const cat = await db.query('SELECT * FROM categories WHERE id = $1', [cat_id]);\n  res.json(cat);\n}\n\nasync function createCategory(req, res) {\n  var cat_name = req.body.name;\n  var cat_description = req.body.description;\n  console.log('Creating category:', cat_name);\n  const cat = await db.query(\n    'INSERT INTO categories (name, description) VALUES ($1, $2) RETURNING *',\n    [cat_name, cat_description]\n  );\n  res.json(cat);\n}\n\nmodule.exports = { getAllCategories, getCategory, createCategory };\n"
      },
      {
        "path": "src/handlers/suppliers.js",
        "content": "const db = require('../db');\n\nasync function getAllSuppliers(req, res) {\n  console.log('Fetching suppliers');\n  const suppliers = await db.query('SELECT * FROM suppliers');\n  res.json(suppliers);\n}\n\nasync function getSupplier(req, res) {\n  var supplier_id = req.params.id;\n  const supplier = await db.query('SELECT * FROM suppliers WHERE id = $1', [supplier_id]);\n  res.json(supplier);\n}\n\nasync function createSupplier(req, res) {\n  var supplier_name = req.body.name;\n  var contact_info = req.body.contact;\n  var supplier_email = req.body.email;\n  console.log('Creating supplier:', supplier_name);\n  const supplier = await db.query(\n    'INSERT INTO suppliers (name, contact, email) VALUES ($1, $2, $3) RETURNING *',\n    [supplier_name, contact_info, supplier_email]\n  );\n  res.json(supplier);\n}\n\nasync function updateSupplier(req, res) {\n  var supplier_name = req.body.name;\n  var contact_info = req.body.contact;\n  var supplier_email = req.body.email;\n  console.log('Updating supplier:', req.params.id);\n  const supplier = await db.query(\n    'UPDATE suppliers SET name = $1, contact = $2, email = $3 WHERE id = $4 RETURNING *',\n    [supplier_name, contact_info, supplier_email, req.params.id]\n  );\n  res.json(supplier);\n}\n\nmodule.exports = { getAllSuppliers, getSupplier, createSupplier, updateSupplier };\n"
      },
      {
        "path": "src/handlers/orders.js",
        "content": "const db = require('../db');\n\n// TODO: validate order items before creating\nasync function createOrder(req, res) {\n  var user_id = req.body.userId;\n  var order_items = req.body.items;\n  var order_total = 0;\n  for (var i = 0; i < order_items.length; i++) {\n    order_total = order_total + order_items[i].price * order_items[i].quantity;\n  }\n  console.log('Creating order for user:', user_id, 'total:', order_total);\n  const order = await db.query(\n    'INSERT INTO orders (user_id, items, total, status) VALUES ($1, $2, $3, $4) RETURNING *',\n    [user_id, JSON.stringify(order_items), order_total, 'pending']\n  );\n  res.json(order);\n}\n\nasync function getOrder(req, res) {\n  var order_id = req.params.id;\n  console.log('Fetching order:', order_id);\n  const order = await db.query('SELECT * FROM orders WHERE id = $1', [order_id]);\n  res.json(order);\n}\n\nasync function getOrdersByStatus(req, res) {\n  var order_status = req.params.status;\n  const orders = await db.query('SELECT * FROM orders WHERE status = $1', [order_status]);\n  res.json(orders);\n}\n\n// TODO: validate status transitions (pending -> confirmed -> shipped -> delivered)\nasync function updateOrderStatus(req, res) {\n  var new_status = req.body.status;\n  console.log('Updating order status:', req.params.id, '->', new_status);\n  const order = await db.query(\n    'UPDATE orders SET status = $1 WHERE id = $2 RETURNING *',\n    [new_status, req.params.id]\n  );\n  res.json(order);\n}\n\nmodule.exports = { createOrder, getOrder, getOrdersByStatus, updateOrderStatus };\n"
      },
      {
        "path": "src/handlers/reports.js",
        "content": "const db = require('../db');\n\n// TODO: add caching for expensive report queries\nasync function getReport(req, res) {\n  var report_type = req.params.type;\n  console.log('Generating report:', report_type);\n  if (report_type == 'inventory') {\n    const items = await db.query('SELECT * FROM items WHERE quantity < 10');\n    res.json({ type: 'low-stock', items: items });\n  } else if (report_type == 'orders') {\n    const orders = await db.query('SELECT * FROM orders WHERE status = $1', ['pending']);\n    res.json({ type: 'pending-orders', orders: orders });\n  } else if (report_type == 'revenue') {\n    const orders = await db.query('SELECT SUM(total) as revenue FROM orders WHERE status = $1', ['delivered']);\n    res.json({ type: 'revenue', data: orders });\n  } else {\n    res.status(400).json({ error: 'Unknown report type' });\n  }\n}\n\nasync function getSummary(req, res) {\n  console.log('Generating summary');\n  const item_count = await db.query('SELECT COUNT(*) as count FROM items');\n  const order_count = await db.query('SELECT COUNT(*) as count FROM orders');\n  const supplier_count = await db.query('SELECT COUNT(*) as count FROM suppliers');\n  res.json({\n    items: item_count,\n    orders: order_count,\n    suppliers: supplier_count\n  });\n}\n\nmodule.exports = { getReport, getSummary };\n"
      },
      {
        "path": "src/db.js",
        "content": "// TODO: add connection pooling\n// TODO: add error handling for connection failures\nconst db = {\n  query: async (sql, params) => {\n    // simulated database\n    return [];\n  }\n};\n\nmodule.exports = db;\n"
      },
      {
        "path": "src/middleware/auth.js",
        "content": "// TODO: implement real authentication\nfunction authenticate(req, res, next) {\n  console.log('Auth check for:', req.path);\n  // placeholder - no actual auth\n  next();\n}\n\n// TODO: implement admin role check\nfunction requireAdmin(req, res, next) {\n  console.log('Admin check for:', req.path);\n  next();\n}\n\nmodule.exports = { authenticate, requireAdmin };\n"
      },
      {
        "path": "src/utils/helpers.js",
        "content": "function format_price(price) {\n  return '$' + price.toFixed(2);\n}\n\nfunction generate_id() {\n  return Math.random().toString(36).substr(2, 9);\n}\n\nfunction paginate_results(array, page, per_page) {\n  var start_index = (page - 1) * per_page;\n  var end_index = start_index + per_page;\n  return {\n    data: array.slice(start_index, end_index),\n    total: array.length,\n    page: page,\n    total_pages: Math.ceil(array.length / per_page)\n  };\n}\n\nmodule.exports = { format_price, generate_id, paginate_results };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "No TODO comments remain in src/handlers/orders.js",
      "type": "file_not_contains",
      "target": "src/handlers/orders.js",
      "pattern": "TODO",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "No TODO comments remain in src/handlers/reports.js",
      "type": "file_not_contains",
      "target": "src/handlers/reports.js",
      "pattern": "TODO",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "No TODO comments remain in src/db.js",
      "type": "file_not_contains",
      "target": "src/db.js",
      "pattern": "TODO",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "No console.log statements remain in src/handlers/items.js",
      "type": "file_not_contains",
      "target": "src/handlers/items.js",
      "pattern": "console\\.log",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "No console.log statements remain in src/handlers/orders.js",
      "type": "file_not_contains",
      "target": "src/handlers/orders.js",
      "pattern": "console\\.log",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "Error handling added to handler files (try/catch blocks)",
      "type": "file_contains",
      "target": "src/handlers/items.js",
      "pattern": "try|catch",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "JSDoc documentation added to handler files",
      "type": "file_contains",
      "target": "src/handlers/items.js",
      "pattern": "/\\*\\*|@param|@returns",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "No TODO comments remain in src/middleware/auth.js",
      "type": "file_not_contains",
      "target": "src/middleware/auth.js",
      "pattern": "TODO",
      "xpBonus": 25
    },
    {
      "id": "bonus-2",
      "description": "No console.log debug statements remain in src/middleware/auth.js",
      "type": "file_not_contains",
      "target": "src/middleware/auth.js",
      "pattern": "console\\.log",
      "xpBonus": 25
    },
    {
      "id": "bonus-3",
      "description": "helpers.js uses camelCase naming (no snake_case function names)",
      "type": "file_not_contains",
      "target": "src/utils/helpers.js",
      "pattern": "function format_price|function generate_id|function paginate_results",
      "xpBonus": 30
    },
    {
      "id": "bonus-4",
      "description": "User creates cleanup-report.md summarizing what was changed",
      "type": "file_exists",
      "target": "cleanup-report.md",
      "xpBonus": 30
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Start by reading through the files to catalog the problems: console.log statements, TODO comments, no try/catch, no JSDoc, snake_case variables. Then decide your strategy: one big loop or multiple focused phases.",
      "xpCost": 25
    },
    {
      "level": 2,
      "text": "A two-phase approach works well. Phase 1: /ralph-loop:ralph-loop 'Remove all console.log and implement/remove all TODO comments in src/. When done, output <promise>CLEANUP_DONE</promise>.' --completion-promise 'CLEANUP_DONE' --max-iterations 15. Phase 2: /ralph-loop:ralph-loop 'Add try/catch to all async functions in handlers/, add JSDoc to all exported functions, rename snake_case to camelCase. When done, output <promise>STANDARDIZE_DONE</promise>.' --completion-promise 'STANDARDIZE_DONE' --max-iterations 15",
      "xpCost": 70
    },
    {
      "level": 3,
      "text": "One-loop approach: /ralph-loop:ralph-loop \"Clean up this entire codebase in src/. (1) Remove all console.log statements. (2) Implement what each TODO asks for, then remove the TODO comment. (3) Add try/catch error handling to every async function in handlers/. (4) Add JSDoc with @param and @returns to every exported function. (5) Rename snake_case variables in helpers.js to camelCase. When all 5 tasks are complete, output <promise>ALL_CLEAN</promise>.\" --completion-promise \"ALL_CLEAN\" --max-iterations 25",
      "xpCost": 140
    }
  ],

  "solution": {
    "approach": "Assess the codebase problems, then use /ralph-loop:ralph-loop (in one or more phases) to systematically clean up: remove debug logs, implement TODOs, add error handling, add JSDoc, and normalize naming. Verify the results after each phase.",
    "example": "Two-phase approach: Phase 1 removes console.log and TODOs. Phase 2 adds try/catch, JSDoc, and fixes naming. Or one big loop with all 5 criteria as a compound completion promise.",
    "alternativeApproaches": [
      "Five separate focused loops, one per issue category",
      "Manual cleanup without Ralph Loop",
      "Single comprehensive loop with compound promise"
    ]
  },

  "learningPoints": [
    "Ralph Loop excels at large-scale, well-defined codebase cleanup tasks",
    "Avoid anti-patterns: scope too broad, unmeasurable promises, conflicting changes",
    "Always verify Ralph Loop's work — read files and search for remaining issues",
    "You can choose between one big loop or multiple focused phases based on complexity",
    "When something isn't working, cancel with /ralph-loop:cancel-ralph and re-scope rather than letting the loop spin"
  ],

  "nextChallenge": "14-001"
}
