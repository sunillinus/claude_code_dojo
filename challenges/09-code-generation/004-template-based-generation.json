{
  "id": "09-004",
  "module": "code-generation",
  "title": "Template-Based Generation",
  "description": "Learn to create reusable generation templates that produce consistent code across multiple instances. Templates turn proven patterns into repeatable recipes that Claude Code can apply on demand.",
  "difficulty": "advanced",
  "xpReward": 275,
  "estimatedMinutes": 15,
  "skills": ["templates", "pattern-replication", "claude-md-configuration", "consistency"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-09-004",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Template-Based Generation\n\nLearn to create reusable templates that produce consistent code across\nmultiple instances.\n\n## What Is a Template Pattern?\n\nA template pattern is a proven code structure that you apply repeatedly.\nInstead of writing each new module from scratch, you define the pattern\nonce and generate instances from it.\n\nReal-world examples:\n- Every API resource follows the same route/controller/service structure\n- Every React component has the same file structure and test file\n- Every database migration follows the same up/down pattern\n- Every CLI command has the same option parsing and help text structure\n\nTemplates are different from the convention-matching you learned in\nchallenge 09-001. Convention-matching reads existing code and replicates\nits style. Templates are explicit, documented patterns that define the\nexact structure, naming rules, and code skeleton for a category of\ncomponents. They are the formalized, reusable version of what you did\ninformally before.\n\n## Why Templates?\n\nWithout templates, you get drift:\n\n```\n// userService.js - first developer\nclass UserService { async getAll() { ... } }\n\n// product-service.js - second developer\nconst getProducts = async () => { ... };\n\n// OrderSvc.js - third developer\nfunction OrderSvc() { this.list = function() { ... } }\n```\n\nSame concept, three different implementations. Every developer made\nreasonable choices, but the result is a codebase that is hard to\nnavigate, hard to refactor, and hard to onboard new people into.\nTemplates enforce consistency:\n\n```\n// userService.js, productService.js, orderService.js\n// All follow the exact same class structure, naming, methods\n```\n\nConsistency is not just about aesthetics. When every resource module\nlooks the same, you can:\n- Find any method in any resource instantly\n- Write generic middleware that works with all resources\n- Onboard new developers who only need to learn one pattern\n- Refactor the pattern once and apply it everywhere\n\n## Creating Templates for Claude Code\n\nThe best place to define templates is in your `CLAUDE.md` file (or a\ndedicated templates document like the `TEMPLATE.md` in this workspace).\nThis ensures Claude Code sees the template every time it works in your\nproject.\n\n### Template Structure\n\nA good template definition has six parts:\n\n1. **Name**: What this template is for (e.g., \"CRUD Resource Template\")\n2. **When to use**: The trigger condition (e.g., \"When I ask for a new API resource\")\n3. **Parameters**: What varies between instances (resource name, fields, etc.)\n4. **File structure**: What files to create and where they go\n5. **Code pattern**: The actual code template with placeholders\n6. **Conventions**: Naming rules, import patterns, error message formats\n\n### Example Template Definition\n\n```markdown\n## CRUD Resource Template\n\nWhen I ask for a new API resource, create these files:\n\n### Parameters\n- RESOURCE_NAME: singular name (e.g., \"product\")\n- RESOURCE_NAME_PLURAL: plural name (e.g., \"products\")\n- FIELDS: list of { name, type, required } objects\n\n### Files to Create\n1. `src/routes/{RESOURCE_NAME_PLURAL}.js` - Express router\n2. `src/services/{RESOURCE_NAME}Service.js` - Business logic\n3. `src/validators/{RESOURCE_NAME}Validator.js` - Validation\n4. `tests/{RESOURCE_NAME}.test.js` - Tests\n\n### Conventions\n- Service class with static methods: getAll, getById, create, update, delete\n- Router uses lowercase plural for paths: /api/{RESOURCE_NAME_PLURAL}\n- Validator exports a validate function returning error array\n- Tests cover all CRUD operations and validation\n```\n\n## Parameterized Generation\n\nTemplates have placeholders that change per instance:\n\n| Parameter | Product Instance | Order Instance |\n|-----------|-----------------|----------------|\n| RESOURCE_NAME | product | order |\n| RESOURCE_NAME_PLURAL | products | orders |\n| FIELDS | name, price, category | items, total, status |\n| RELATIONSHIPS | belongs to category | has many items |\n\nWhen you ask Claude Code to generate from a template, you specify\nthe parameter values. The prompt should clearly state which template\nto use and what the parameter values are:\n\n```\nUsing the CRUD Resource Template, generate a 'product' resource with\nfields: name (string, required), price (number, required), category\n(string, optional), inStock (boolean, default true).\n```\n\nNotice how this prompt is short but precise. The template handles\nall the structural decisions. Your prompt only provides the\nresource-specific details.\n\n## Template Inheritance\n\nSometimes you need variations of a base template:\n\n- **Base template**: Standard CRUD resource\n- **Variation A**: CRUD resource with soft delete (adds deletedAt field)\n- **Variation B**: CRUD resource with audit log (adds createdBy, updatedBy)\n- **Variation C**: Read-only resource (only getAll, getById - no create/update/delete)\n\nDefine the base template and then describe variations as deltas:\n\"Same as CRUD Resource Template, but omit delete and update methods.\"\n\nThis layered approach keeps your template documentation manageable.\nYou do not need to duplicate the entire template for each variation.\n\n## Verifying Template Consistency\n\nAfter generating multiple instances from a template, verify consistency:\n\n- Do all services have the same method signatures?\n- Do all route files export using the same naming convention?\n- Do all 404 error messages follow the same format?\n- Are imports structured identically across all instances?\n- Does the validate method check resource-specific constraints?\n\nIf any instance deviates from the template, ask Claude Code to fix it.\nThe whole point of templates is uniformity.\n\n## When to Use Templates vs. One-Off Generation\n\n| Use Templates When | Use One-Off Generation When |\n|-------------------|---------------------------|\n| Building 3+ similar things | Building something unique |\n| Team needs consistency | Exploring/prototyping |\n| Pattern is proven and stable | Pattern is still evolving |\n| Onboarding new team members | Solo exploration |\n\nA common mistake is creating templates too early. If you have only built\none instance of a pattern, it is not yet proven. Build two or three\ninstances manually, extract the common pattern, and then document it as\na template. Templates should codify what works, not predict what might.\n\n## Your Exercise\n\nThis workspace has a `TEMPLATE.md` file that defines a CRUD resource\ntemplate. It also has one existing implementation (`products`) that was\nbuilt from this template. The products implementation in\n`src/services/productService.js` and `src/routes/products.js` shows\nexactly what the template produces when applied.\n\nYour tasks:\n1. Study the template definition in TEMPLATE.md\n2. Study the existing products implementation to see the template in action\n3. Use the template to generate two more resources: `categories` and `reviews`\n4. Verify all three resources follow the template consistently\n5. Each resource should have its own unique fields and validations while\n   sharing the structural pattern\n\n## Objectives\n1. Generate categories resource (service + routes) from the template\n2. Generate reviews resource (service + routes) from the template\n3. All resources must follow the template pattern consistently\n4. Each resource must have appropriate fields for its domain\n"
      },
      {
        "path": "TEMPLATE.md",
        "content": "# CRUD Resource Template\n\nUse this template when creating a new API resource.\n\n## Parameters\n- `RESOURCE`: Singular resource name (e.g., \"product\")\n- `RESOURCES`: Plural resource name (e.g., \"products\")\n- `FIELDS`: Resource-specific fields (beyond id, createdAt, updatedAt)\n- `REQUIRED_FIELDS`: Which fields are required on creation\n\n## Files to Generate\n\n### 1. Service: `src/services/{RESOURCE}Service.js`\n\n```javascript\nimport { v4 as uuidv4 } from 'uuid';\n\nconst {RESOURCES} = [];\n\nexport class {RESOURCE_CLASS}Service {\n  static findAll(filters = {}) {\n    let results = [...{RESOURCES}];\n    // Apply filters specific to this resource\n    return results;\n  }\n\n  static findById(id) {\n    return {RESOURCES}.find((item) => item.id === id) || null;\n  }\n\n  static create(data) {\n    // Validate required fields\n    const errors = this.validate(data);\n    if (errors.length > 0) {\n      return { errors };\n    }\n    const item = {\n      id: uuidv4(),\n      ...data,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    {RESOURCES}.push(item);\n    return { data: item };\n  }\n\n  static update(id, data) {\n    const index = {RESOURCES}.findIndex((item) => item.id === id);\n    if (index === -1) return null;\n    {RESOURCES}[index] = {\n      ...{RESOURCES}[index],\n      ...data,\n      updatedAt: new Date().toISOString()\n    };\n    return {RESOURCES}[index];\n  }\n\n  static delete(id) {\n    const index = {RESOURCES}.findIndex((item) => item.id === id);\n    if (index === -1) return false;\n    {RESOURCES}.splice(index, 1);\n    return true;\n  }\n\n  static validate(data) {\n    const errors = [];\n    // Check each REQUIRED_FIELD\n    return errors;\n  }\n}\n```\n\n### 2. Routes: `src/routes/{RESOURCES}.js`\n\n```javascript\nimport { Router } from 'express';\nimport { {RESOURCE_CLASS}Service } from '../services/{RESOURCE}Service.js';\n\nconst router = Router();\n\nrouter.get('/', (req, res) => {\n  const items = {RESOURCE_CLASS}Service.findAll(req.query);\n  res.json({ data: items, count: items.length });\n});\n\nrouter.get('/:id', (req, res) => {\n  const item = {RESOURCE_CLASS}Service.findById(req.params.id);\n  if (!item) return res.status(404).json({ error: '{RESOURCE_CLASS} not found' });\n  res.json({ data: item });\n});\n\nrouter.post('/', (req, res) => {\n  const result = {RESOURCE_CLASS}Service.create(req.body);\n  if (result.errors) {\n    return res.status(400).json({ errors: result.errors });\n  }\n  res.status(201).json({ data: result.data });\n});\n\nrouter.put('/:id', (req, res) => {\n  const item = {RESOURCE_CLASS}Service.update(req.params.id, req.body);\n  if (!item) return res.status(404).json({ error: '{RESOURCE_CLASS} not found' });\n  res.json({ data: item });\n});\n\nrouter.delete('/:id', (req, res) => {\n  const deleted = {RESOURCE_CLASS}Service.delete(req.params.id);\n  if (!deleted) return res.status(404).json({ error: '{RESOURCE_CLASS} not found' });\n  res.status(204).end();\n});\n\nexport { router as {RESOURCES}Routes };\n```\n\n### 3. Register in `src/app.js`\n\nAdd import and app.use('/api/{RESOURCES}', {RESOURCES}Routes);\n\n## Naming Conventions\n- Service class: PascalCase + \"Service\" (e.g., ProductService)\n- Route file: lowercase plural (e.g., products.js)\n- Route export: camelCase plural + \"Routes\" (e.g., productsRoutes)\n- API path: /api/{lowercase plural} (e.g., /api/products)\n- 404 message: '{PascalCase singular} not found' (e.g., 'Product not found')\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"template-api\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"node src/app.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"uuid\": \"^9.0.0\"\n  }\n}"
      },
      {
        "path": "src/app.js",
        "content": "import express from 'express';\nimport { productsRoutes } from './routes/products.js';\n\nconst app = express();\napp.use(express.json());\n\n// Resource routes\napp.use('/api/products', productsRoutes);\n\n// Error handling\napp.use((err, req, res, next) => {\n  res.status(err.status || 500).json({ error: err.message || 'Internal error' });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`Server running on port ${PORT}`));\n\nexport default app;\n"
      },
      {
        "path": "src/services/productService.js",
        "content": "import { v4 as uuidv4 } from 'uuid';\n\nconst products = [];\n\nexport class ProductService {\n  static findAll(filters = {}) {\n    let results = [...products];\n    if (filters.category) {\n      results = results.filter((p) => p.category === filters.category);\n    }\n    if (filters.inStock !== undefined) {\n      results = results.filter((p) => p.inStock === (filters.inStock === 'true'));\n    }\n    return results;\n  }\n\n  static findById(id) {\n    return products.find((item) => item.id === id) || null;\n  }\n\n  static create(data) {\n    const errors = this.validate(data);\n    if (errors.length > 0) {\n      return { errors };\n    }\n    const item = {\n      id: uuidv4(),\n      name: data.name,\n      price: data.price,\n      category: data.category || 'uncategorized',\n      inStock: data.inStock !== undefined ? data.inStock : true,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    products.push(item);\n    return { data: item };\n  }\n\n  static update(id, data) {\n    const index = products.findIndex((item) => item.id === id);\n    if (index === -1) return null;\n    products[index] = {\n      ...products[index],\n      ...data,\n      updatedAt: new Date().toISOString()\n    };\n    return products[index];\n  }\n\n  static delete(id) {\n    const index = products.findIndex((item) => item.id === id);\n    if (index === -1) return false;\n    products.splice(index, 1);\n    return true;\n  }\n\n  static validate(data) {\n    const errors = [];\n    if (!data.name) errors.push('Name is required');\n    if (data.price === undefined || data.price === null) errors.push('Price is required');\n    if (data.price !== undefined && typeof data.price !== 'number') errors.push('Price must be a number');\n    if (data.price !== undefined && data.price < 0) errors.push('Price must not be negative');\n    return errors;\n  }\n}\n"
      },
      {
        "path": "src/routes/products.js",
        "content": "import { Router } from 'express';\nimport { ProductService } from '../services/productService.js';\n\nconst router = Router();\n\nrouter.get('/', (req, res) => {\n  const items = ProductService.findAll(req.query);\n  res.json({ data: items, count: items.length });\n});\n\nrouter.get('/:id', (req, res) => {\n  const item = ProductService.findById(req.params.id);\n  if (!item) return res.status(404).json({ error: 'Product not found' });\n  res.json({ data: item });\n});\n\nrouter.post('/', (req, res) => {\n  const result = ProductService.create(req.body);\n  if (result.errors) {\n    return res.status(400).json({ errors: result.errors });\n  }\n  res.status(201).json({ data: result.data });\n});\n\nrouter.put('/:id', (req, res) => {\n  const item = ProductService.update(req.params.id, req.body);\n  if (!item) return res.status(404).json({ error: 'Product not found' });\n  res.json({ data: item });\n});\n\nrouter.delete('/:id', (req, res) => {\n  const deleted = ProductService.delete(req.params.id);\n  if (!deleted) return res.status(404).json({ error: 'Product not found' });\n  res.status(204).end();\n});\n\nexport { router as productsRoutes };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create CategoryService following the template pattern",
      "type": "file_exists",
      "target": "src/services/categoryService.js",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "CategoryService uses static class methods matching template (findAll, findById, create, validate)",
      "type": "file_contains",
      "target": "src/services/categoryService.js",
      "pattern": "class CategoryService",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Create category routes following the template pattern",
      "type": "file_exists",
      "target": "src/routes/categories.js",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Category routes use the template naming convention (categoriesRoutes export)",
      "type": "file_contains",
      "target": "src/routes/categories.js",
      "pattern": "categoriesRoutes|CategoryService",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Create ReviewService following the template pattern",
      "type": "file_exists",
      "target": "src/services/reviewService.js",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "ReviewService uses static class methods matching template",
      "type": "file_contains",
      "target": "src/services/reviewService.js",
      "pattern": "class ReviewService",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "Create review routes following the template pattern",
      "type": "file_exists",
      "target": "src/routes/reviews.js",
      "required": true
    },
    {
      "id": "obj-8",
      "description": "Review routes import ReviewService and follow template structure",
      "type": "file_contains",
      "target": "src/routes/reviews.js",
      "pattern": "reviewsRoutes|ReviewService",
      "required": true
    },
    {
      "id": "obj-9",
      "description": "Category routes follow template error pattern ('Category not found')",
      "type": "file_contains",
      "target": "src/routes/categories.js",
      "pattern": "Category not found",
      "required": true
    },
    {
      "id": "obj-10",
      "description": "Review routes follow template error pattern ('Review not found')",
      "type": "file_contains",
      "target": "src/routes/reviews.js",
      "pattern": "Review not found",
      "required": true
    },
    {
      "id": "obj-11",
      "description": "Both new services have a validate method with resource-specific validation",
      "type": "file_contains",
      "target": "src/services/categoryService.js",
      "pattern": "static validate",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "New routes are registered in src/app.js",
      "type": "file_contains",
      "target": "src/app.js",
      "pattern": "categoriesRoutes|/api/categories",
      "xpBonus": 30
    },
    {
      "id": "bonus-2",
      "description": "ReviewService has domain-specific validation (rating range, productId reference)",
      "type": "file_contains",
      "target": "src/services/reviewService.js",
      "pattern": "rating|productId|score|review.*required",
      "xpBonus": 30
    },
    {
      "id": "bonus-3",
      "description": "CategoryService has domain-specific filtering in findAll",
      "type": "file_contains",
      "target": "src/services/categoryService.js",
      "pattern": "filter|filters\\.",
      "xpBonus": 30
    },
    {
      "id": "bonus-4",
      "description": "ReviewService validate method checks domain-specific constraints",
      "type": "file_contains",
      "target": "src/services/reviewService.js",
      "pattern": "validate.*\\{[\\s\\S]*?(rating|score|body|text|content|comment)",
      "xpBonus": 30
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Start by reading TEMPLATE.md and the existing product implementation (src/services/productService.js and src/routes/products.js). The template defines the exact structure. The product files show a real implementation of that template. Your job is to ask Claude Code to create two more implementations with different parameters (categories and reviews).",
      "xpCost": 20
    },
    {
      "level": 2,
      "text": "Use the template explicitly in your prompt: 'Read TEMPLATE.md and the existing product implementation in src/services/productService.js and src/routes/products.js. Using this template, generate a categories resource. A category has: name (string, required), description (string, optional), parentId (string, optional - for subcategories). Follow the template exactly: class name CategoryService, route export categoriesRoutes, 404 message \"Category not found\".'",
      "xpCost": 55
    },
    {
      "level": 3,
      "text": "After generating categories, generate reviews with a similar prompt: 'Using the same CRUD Resource Template, generate a reviews resource. A review has: productId (string, required), rating (number, required, 1-5), title (string, required), body (string, optional), author (string, required). Same pattern: ReviewService class, reviewsRoutes export, \"Review not found\". Validate that rating is between 1 and 5.' Finally, update src/app.js to register both new route sets.",
      "xpCost": 110
    }
  ],

  "solution": {
    "approach": "Read the template definition and the existing product implementation, then use Claude Code to generate categories and reviews resources by specifying the template parameters (resource name, fields, required fields) for each one.",
    "example": "First prompt: 'Read TEMPLATE.md and the product implementation files. Using the template, generate the categories resource (service + routes). Fields: name (required), description (optional), parentId (optional).' Second prompt: 'Now generate the reviews resource using the same template. Fields: productId (required), rating (number 1-5, required), title (required), body (optional), author (required).' Third prompt: 'Register both new routes in src/app.js following the existing pattern.'",
    "alternativeApproaches": [
      "Generate both resources in a single prompt with all parameters specified",
      "Generate services first, then routes, to verify consistency at each layer",
      "Ask Claude Code to generate a script that applies the template, rather than applying it directly"
    ]
  },

  "learningPoints": [
    "Templates enforce consistency across multiple instances of the same pattern",
    "A template definition has: name, parameters, file structure, code pattern, and naming conventions",
    "CLAUDE.md or a dedicated template file is the best place to store templates so Claude Code always has access",
    "Parameterized generation lets you specify what varies (fields, names) while keeping what's constant (structure, patterns)",
    "Template-generated code should be domain-appropriate: same pattern, but fields and validations fit each resource"
  ],

  "nextChallenge": "10-001"
}