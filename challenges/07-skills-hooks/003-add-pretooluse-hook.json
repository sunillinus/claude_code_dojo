{
  "id": "07-003",
  "module": "skills-hooks",
  "title": "Add a PreToolUse Hook",
  "description": "Learn what hooks are in Claude Code, how they respond to events, and create a PreToolUse hook that blocks dangerous Bash commands before they execute.",
  "difficulty": "advanced",
  "xpReward": 350,
  "estimatedMinutes": 15,
  "skills": ["hook-creation", "pretooluse-validation", "safety-scripting"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-07-003",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Add a PreToolUse Hook\n\nLearn what hooks are, how they work, and create a PreToolUse hook that\nblocks dangerous shell commands.\n\n---\n\n## What Are Hooks?\n\nHooks are **shell commands that run automatically** in response to\nClaude Code events. When Claude is about to use a tool, finishes using\na tool, or completes a response, hooks can intercept these events to\nvalidate, log, transform, or block operations.\n\nThink of hooks like middleware in a web framework. Just as Express\nmiddleware can intercept HTTP requests before they reach a handler,\nhooks can intercept tool usage before Claude executes it.\n\n## Hook Events\n\nClaude Code fires hooks at specific points in its execution:\n\n| Event | When It Fires | Can Block? | Use Cases |\n|-------|--------------|------------|----------|\n| `PreToolUse` | Before a tool runs | Yes | Validate, block dangerous ops |\n| `PostToolUse` | After a tool completes | No | Format, lint, log, notify |\n| `Stop` | When Claude finishes responding | No | Summary, cleanup, metrics |\n| `SubagentStop` | When a subagent finishes | No | Aggregate results |\n| `Notification` | When a notification triggers | No | Custom alerts |\n\nThe most powerful event is **PreToolUse** because it can **block**\noperations before they happen. If a PreToolUse hook exits with a\nnon-zero status code or outputs a JSON response with\n`\"decision\": \"block\"`, the tool invocation is cancelled.\n\n## Where Hooks Are Configured\n\nHooks are configured in `.claude/settings.json` -- either in the\nproject directory (for project-specific hooks) or in your home\ndirectory `~/.claude/settings.json` (for global hooks).\n\n```json\n{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"command\": \"/path/to/check-command.sh\"\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"command\": \"/path/to/after-write.sh\"\n      }\n    ]\n  }\n}\n```\n\n### Hook Configuration Fields\n\n| Field | Purpose |\n|-------|---------|\n| `matcher` | Which tool to match. Use a tool name like `\"Bash\"`, `\"Write\"`, `\"Edit\"`, or `\"*\"` for all tools. |\n| `command` | The shell command or script to run when the hook fires. |\n\nMultiple hooks can listen to the same event. They all run, and if ANY\nPreToolUse hook blocks, the operation is blocked.\n\n## How Hook Scripts Work\n\nWhen a hook fires, Claude Code:\n1. Runs your `command` as a shell script\n2. Passes JSON data on **stdin** describing the tool call\n3. Sets **environment variables** with tool information\n4. Reads the script's **stdout** for a response\n5. Checks the **exit code** (non-zero = block for PreToolUse)\n\n### Input: JSON on stdin\n\nThe hook script receives a JSON object on stdin with details about\nthe tool invocation:\n\n```json\n{\n  \"tool_name\": \"Bash\",\n  \"tool_input\": {\n    \"command\": \"rm -rf /important-data\",\n    \"description\": \"Delete the data directory\"\n  }\n}\n```\n\nFor the Write tool, `tool_input` includes `file_path` and `content`.\nFor Edit, it includes `file_path`, `old_string`, and `new_string`.\n\n### Environment Variables\n\nThese environment variables are set when the hook runs:\n\n| Variable | Value |\n|----------|---------|\n| `CLAUDE_TOOL_NAME` | The tool being invoked (e.g., \"Bash\") |\n| `CLAUDE_TOOL_INPUT` | JSON string of the tool input |\n\n### Output: Blocking a Tool\n\nA PreToolUse hook can block an operation in two ways:\n\n**Method 1: Non-zero exit code**\n```bash\n#!/bin/bash\n# Read the command from stdin\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command')\n\nif echo \"$command\" | grep -q 'rm -rf'; then\n  echo \"BLOCKED: rm -rf is not allowed\"\n  exit 1\nfi\n```\n\n**Method 2: JSON response with decision**\n```bash\n#!/bin/bash\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command')\n\nif echo \"$command\" | grep -q 'rm -rf'; then\n  echo '{\"decision\": \"block\", \"reason\": \"rm -rf is dangerous\"}'\nelse\n  echo '{\"decision\": \"allow\"}'\nfi\n```\n\n## A Complete Example\n\nHere is a full example of a PreToolUse hook that prevents force-pushing\nto git:\n\n**Script: `.claude/hooks/no-force-push.sh`**\n```bash\n#!/bin/bash\ninput=$(cat)\ncommand=$(echo \"$input\" | jq -r '.tool_input.command // empty')\n\n# Check for force push patterns\nif echo \"$command\" | grep -qE 'git push.*--force|git push.*-f'; then\n  echo \"BLOCKED: Force push is not allowed. Use --force-with-lease instead.\"\n  exit 1\nfi\n\n# Allow everything else\nexit 0\n```\n\n**Configuration: `.claude/settings.json`**\n```json\n{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"command\": \".claude/hooks/no-force-push.sh\"\n      }\n    ]\n  }\n}\n```\n\nThis fires before every Bash tool invocation. If the command contains\n`git push --force` or `git push -f`, the script exits with code 1\nand the Bash call is blocked. Otherwise, it exits with code 0 and\nthe command proceeds.\n\n## Key Design Principles for Hooks\n\n1. **Keep hooks fast** -- they run synchronously before every tool call\n   that matches, so slow hooks make Claude feel sluggish\n2. **Be specific with matchers** -- use `\"Bash\"` instead of `\"*\"` if\n   you only care about shell commands\n3. **Fail safe** -- if your script errors, Claude should still work;\n   test error paths\n4. **Use jq for JSON parsing** -- the input is JSON, and jq is the\n   standard tool for extracting fields\n5. **Exit 0 by default** -- only exit non-zero when you explicitly\n   want to block\n\n---\n\n## Your Task\n\nCreate a PreToolUse hook that blocks dangerous Bash commands. You need:\n\n### 1. The Hook Script: `.claude/hooks/block-dangerous.sh`\nA bash script that:\n- Reads JSON from stdin to get the command being run\n- Checks for dangerous patterns: `rm -rf`, `git push --force`,\n  `git push -f`, `chmod 777`, `> /dev/sda`\n- Blocks (exits non-zero) if a dangerous pattern is found\n- Allows (exits 0) for all other commands\n\n### 2. The Settings File: `.claude/settings.json`\nA valid JSON configuration that registers your hook:\n- Hooks section with PreToolUse event\n- Matcher set to \"Bash\" (only intercept shell commands)\n- Command pointing to your hook script\n\n## Objectives\n1. Create `.claude/hooks/block-dangerous.sh` -- the hook script\n2. Create `.claude/settings.json` -- the hook configuration\n3. The script must check for dangerous command patterns\n4. The settings must register the hook for PreToolUse on Bash\n"
      },
      {
        "path": "src/app.js",
        "content": "// Safe project file\nconst express = require('express');\n\nfunction createApp() {\n  const app = express();\n  app.get('/', (req, res) => res.json({ status: 'ok' }));\n  return app;\n}\n\nmodule.exports = { createApp };\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"hook-demo-project\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A project demonstrating Claude Code hooks\",\n  \"scripts\": {\n    \"start\": \"node src/app.js\",\n    \"test\": \"echo 'Tests passed'\"\n  }\n}\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create the hook script at .claude/hooks/block-dangerous.sh",
      "type": "file_exists",
      "target": ".claude/hooks/block-dangerous.sh",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Create the settings configuration at .claude/settings.json",
      "type": "file_exists",
      "target": ".claude/settings.json",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Hook script checks for dangerous command patterns (rm -rf, force push, etc.)",
      "type": "file_contains",
      "target": ".claude/hooks/block-dangerous.sh",
      "pattern": "rm -rf|rm.*-rf|force|--force|-f.*push|chmod 777|dangerous|block",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Hook script reads input (stdin or environment variable) to get the command",
      "type": "file_contains",
      "target": ".claude/hooks/block-dangerous.sh",
      "pattern": "cat|stdin|read|CLAUDE_TOOL_INPUT|tool_input|jq",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Hook script exits with non-zero code or outputs block decision when dangerous pattern found",
      "type": "file_contains",
      "target": ".claude/hooks/block-dangerous.sh",
      "pattern": "exit 1|exit [2-9]|decision.*block|BLOCK",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "Settings file registers the hook for PreToolUse on Bash",
      "type": "file_contains",
      "target": ".claude/settings.json",
      "pattern": "PreToolUse",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "Settings file has a matcher for Bash tool",
      "type": "file_contains",
      "target": ".claude/settings.json",
      "pattern": "Bash",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Hook script is marked as executable (has shebang line)",
      "type": "file_contains",
      "target": ".claude/hooks/block-dangerous.sh",
      "pattern": "#!/bin/bash|#!/usr/bin/env bash|#!/bin/sh",
      "xpBonus": 30
    },
    {
      "id": "bonus-2",
      "description": "Hook checks for multiple distinct dangerous patterns (at least 3)",
      "type": "file_contains",
      "target": ".claude/hooks/block-dangerous.sh",
      "pattern": "rm.*-rf.*force|rm.*-rf.*chmod|force.*rm.*-rf|force.*chmod|chmod.*rm.*-rf|chmod.*force",
      "xpBonus": 50
    },
    {
      "id": "bonus-3",
      "description": "Settings file includes the command path pointing to the hook script",
      "type": "file_contains",
      "target": ".claude/settings.json",
      "pattern": "block-dangerous|hooks/",
      "xpBonus": 30
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "You need two files: a bash script at .claude/hooks/block-dangerous.sh that checks commands, and .claude/settings.json that registers the hook. The script reads JSON from stdin using 'cat' and parses it with 'jq' to extract the command, then uses grep to check for dangerous patterns.",
      "xpCost": 25
    },
    {
      "level": 2,
      "text": "The hook script pattern: (1) Read stdin with input=$(cat), (2) Extract command with jq: command=$(echo \"$input\" | jq -r '.tool_input.command'), (3) Check patterns with grep -qE for 'rm -rf|git push.*--force|chmod 777', (4) If match: echo reason and exit 1, (5) If no match: exit 0. The settings.json needs: {\"hooks\": {\"PreToolUse\": [{\"matcher\": \"Bash\", \"command\": \".claude/hooks/block-dangerous.sh\"}]}}",
      "xpCost": 70
    },
    {
      "level": 3,
      "text": "Create .claude/hooks/block-dangerous.sh with: #!/bin/bash, input=$(cat), command=$(echo \"$input\" | jq -r '.tool_input.command // empty'), then if echo \"$command\" | grep -qE 'rm\\s+-rf|git push.*(--force|-f)|chmod 777'; then echo BLOCKED and exit 1; fi; exit 0. Create .claude/settings.json with: {\"hooks\": {\"PreToolUse\": [{\"matcher\": \"Bash\", \"command\": \".claude/hooks/block-dangerous.sh\"}]}}. Then chmod +x the script.",
      "xpCost": 130
    }
  ],

  "solution": {
    "approach": "Create a bash hook script that reads JSON from stdin, extracts the command, checks against dangerous patterns with grep, and exits non-zero to block. Then register it in .claude/settings.json under hooks.PreToolUse with matcher 'Bash'.",
    "example": "Create .claude/hooks/block-dangerous.sh that reads stdin, extracts command with jq, greps for 'rm -rf|git push --force|chmod 777', exits 1 if found. Create .claude/settings.json with hooks.PreToolUse containing the matcher and command path.",
    "alternativeApproaches": [
      "Use the JSON output method with decision: block instead of exit codes",
      "Use the CLAUDE_TOOL_INPUT environment variable instead of reading stdin"
    ]
  },

  "learningPoints": [
    "Hooks are shell scripts that run automatically in response to Claude Code events like PreToolUse, PostToolUse, and Stop",
    "PreToolUse hooks can block operations by exiting with a non-zero code or outputting {\"decision\": \"block\"}",
    "Hook configuration lives in .claude/settings.json under the 'hooks' key, with matcher and command fields",
    "The matcher field determines which tool triggers the hook -- use specific tool names like 'Bash' rather than '*' for targeted control",
    "Hook scripts receive JSON on stdin with tool_name and tool_input, and can use jq to parse the data"
  ],

  "nextChallenge": "07-004"
}