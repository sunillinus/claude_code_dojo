{
  "id": "06-002",
  "module": "subagents",
  "title": "Parallel & Background Subagents",
  "description": "Learn to run multiple subagents in parallel and use background agents. This is key to working efficiently on complex tasks.",
  "difficulty": "intermediate",
  "xpReward": 250,
  "estimatedMinutes": 15,
  "skills": ["parallel-subagents", "background-agents"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-06-002",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Parallel & Background Subagents\n\nLearn to run subagents in parallel and in the background.\n\n## Parallel Subagents\n\nWhen you have independent tasks, Claude Code can spawn multiple\nsubagents at the same time. Each runs in its own context:\n\n```\nYou: \"Research auth, database, and API structure simultaneously\"\n\nClaude Code spawns:\n  [Explore Agent 1] → researching auth\n  [Explore Agent 2] → researching database   (all run at same time)\n  [Explore Agent 3] → researching API\n```\n\nThis is much faster than doing them one at a time.\n\n## Background Subagents\n\nNormally, subagents block - you wait for them to finish. But you can\nask for background execution:\n\n- \"Run this in the background\"\n- \"Check on that background task\"\n- \"What's the status of the background agent?\"\n\nBackground agents:\n- Return immediately with a task ID\n- Write output to a file you can check later\n- Let you continue working while they run\n\n## Resuming Agents\n\nEvery subagent gets an agent ID when it finishes. You can resume it:\n- \"Resume that explore agent to dig deeper into the auth module\"\n- The agent picks up with its full previous context preserved\n\n## Objectives\n1. Ask for 3 parallel explore agents to research different parts of this codebase\n2. Ask for a background agent to do a longer task\n3. Create parallel-notes.md documenting the experience\n"
      },
      {
        "path": "src/index.js",
        "content": "const express = require('express');\nconst { authMiddleware } = require('./auth/middleware');\nconst { connectDB } = require('./db/connection');\nconst routes = require('./routes');\n\nconst app = express();\n\napp.use(express.json());\napp.use('/api', authMiddleware, routes);\n\nconnectDB().then(() => {\n  app.listen(3000, () => console.log('Server running'));\n});\n\nmodule.exports = app;\n"
      },
      {
        "path": "src/auth/middleware.js",
        "content": "const jwt = require('jsonwebtoken');\nconst { SECRET } = require('./config');\n\nfunction authMiddleware(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token' });\n  \n  try {\n    req.user = jwt.verify(token, SECRET);\n    next();\n  } catch {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nmodule.exports = { authMiddleware };\n"
      },
      {
        "path": "src/auth/config.js",
        "content": "module.exports = {\n  SECRET: process.env.JWT_SECRET || 'dev-secret',\n  TOKEN_EXPIRY: '24h'\n};\n"
      },
      {
        "path": "src/auth/service.js",
        "content": "const jwt = require('jsonwebtoken');\nconst { SECRET, TOKEN_EXPIRY } = require('./config');\nconst { User } = require('../db/models/User');\n\nasync function login(email, password) {\n  const user = await User.findByEmail(email);\n  if (!user || !user.checkPassword(password)) {\n    throw new Error('Invalid credentials');\n  }\n  return jwt.sign({ id: user.id, email }, SECRET, { expiresIn: TOKEN_EXPIRY });\n}\n\nmodule.exports = { login };\n"
      },
      {
        "path": "src/db/connection.js",
        "content": "const { Pool } = require('pg');\n\nconst pool = new Pool({\n  host: process.env.DB_HOST || 'localhost',\n  database: process.env.DB_NAME || 'app',\n  user: process.env.DB_USER || 'postgres',\n  password: process.env.DB_PASS || 'postgres'\n});\n\nasync function connectDB() {\n  await pool.connect();\n  console.log('Database connected');\n}\n\nasync function query(sql, params) {\n  return pool.query(sql, params);\n}\n\nmodule.exports = { connectDB, query, pool };\n"
      },
      {
        "path": "src/db/models/User.js",
        "content": "const { query } = require('../connection');\nconst bcrypt = require('bcrypt');\n\nclass User {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n\n  static async findByEmail(email) {\n    const result = await query('SELECT * FROM users WHERE email = $1', [email]);\n    return result.rows[0] ? new User(result.rows[0]) : null;\n  }\n\n  static async create(data) {\n    const hash = await bcrypt.hash(data.password, 10);\n    const result = await query(\n      'INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING *',\n      [data.email, hash]\n    );\n    return new User(result.rows[0]);\n  }\n\n  checkPassword(password) {\n    return bcrypt.compareSync(password, this.password_hash);\n  }\n}\n\nmodule.exports = { User };\n"
      },
      {
        "path": "src/db/models/Product.js",
        "content": "const { query } = require('../connection');\n\nclass Product {\n  constructor(data) {\n    Object.assign(this, data);\n  }\n\n  static async findAll() {\n    const result = await query('SELECT * FROM products');\n    return result.rows.map(r => new Product(r));\n  }\n\n  static async findById(id) {\n    const result = await query('SELECT * FROM products WHERE id = $1', [id]);\n    return result.rows[0] ? new Product(result.rows[0]) : null;\n  }\n}\n\nmodule.exports = { Product };\n"
      },
      {
        "path": "src/routes/index.js",
        "content": "const router = require('express').Router();\nrouter.use('/users', require('./users'));\nrouter.use('/products', require('./products'));\nmodule.exports = router;\n"
      },
      {
        "path": "src/routes/users.js",
        "content": "const router = require('express').Router();\nconst { User } = require('../db/models/User');\nconst { login } = require('../auth/service');\n\nrouter.post('/login', async (req, res) => {\n  try {\n    const token = await login(req.body.email, req.body.password);\n    res.json({ token });\n  } catch (e) {\n    res.status(401).json({ error: e.message });\n  }\n});\n\nrouter.post('/register', async (req, res) => {\n  const user = await User.create(req.body);\n  res.json({ id: user.id, email: user.email });\n});\n\nmodule.exports = router;\n"
      },
      {
        "path": "src/routes/products.js",
        "content": "const router = require('express').Router();\nconst { Product } = require('../db/models/Product');\n\nrouter.get('/', async (req, res) => {\n  const products = await Product.findAll();\n  res.json(products);\n});\n\nrouter.get('/:id', async (req, res) => {\n  const product = await Product.findById(req.params.id);\n  if (!product) return res.status(404).json({ error: 'Not found' });\n  res.json(product);\n});\n\nmodule.exports = router;\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create parallel-notes.md",
      "type": "file_exists",
      "target": "parallel-notes.md",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Notes cover parallel execution",
      "type": "file_contains",
      "target": "parallel-notes.md",
      "pattern": "[Pp]arallel|[Ss]imultaneous|[Cc]oncurrent|at the same time|at once",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Notes cover background agents",
      "type": "file_contains",
      "target": "parallel-notes.md",
      "pattern": "[Bb]ackground|non.blocking|task.?[Ii][Dd]|output.?file",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Notes include findings from at least 2 different areas of the codebase",
      "type": "file_contains",
      "target": "parallel-notes.md",
      "pattern": "[Aa]uth|[Dd]atabase|[Rr]oute|[Mm]odel",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Document how parallel agents save time vs sequential",
      "type": "file_contains",
      "target": "parallel-notes.md",
      "pattern": "[Ff]aster|[Ss]peed|[Tt]ime|[Ee]fficient|sequential",
      "xpBonus": 50
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Ask Claude: 'Use 3 parallel explore agents to research: 1) the auth system, 2) the database layer, 3) the API routes'",
      "xpCost": 20
    },
    {
      "level": 2,
      "text": "For background agents, try: 'Run an agent in the background to create a comprehensive architecture document'. Then check on it with 'What's the status of that background task?'",
      "xpCost": 50
    },
    {
      "level": 3,
      "text": "Your parallel-notes.md should cover: 1) What happened when you ran parallel agents (they all started at once), 2) What happened with the background agent (you got a task ID back), 3) Findings from the research, 4) When parallel execution is useful vs sequential.",
      "xpCost": 95
    }
  ],

  "solution": {
    "approach": "Request parallel exploration, try a background agent, then document the experience.",
    "example": "Run 3 explore agents in parallel, then a background agent, document in parallel-notes.md",
    "alternativeApproaches": [
      "Ask for parallel research on auth, db, and routes, then document",
      "Request concurrent exploration of different code areas"
    ]
  },

  "learningPoints": [
    "Claude Code can spawn multiple subagents simultaneously for independent tasks",
    "Parallel execution is faster than sequential for independent research",
    "Background agents return immediately and let you continue working",
    "Background agents write to an output file you can check with Read or tail",
    "Each agent gets an ID you can use to resume it later"
  ],

  "nextChallenge": "06-003"
}
