{
  "id": "16-002",
  "module": "agentic-loops",
  "title": "Crafting Completion Promises",
  "description": "Master completion promises — the measurable \"done\" criteria that make Ralph Loop effective — then use `/ralph-loop:ralph-loop` to eliminate every TODO in a project.\n\n## What Are Completion Promises?\n\nA completion promise is the measurable definition of \"done\" that you give Ralph Loop. It's how Claude knows when to stop iterating. Without a clear promise, a loop might run forever or stop too early.\n\nThink of it as a contract: \"Keep working until THIS specific, checkable condition is true.\"\n\n## Good vs Bad Promises\n\nThe key test: **Can Claude verify this without human judgment?**\n\n| Bad (Vague) | Good (Measurable) | Why It's Better |\n|-------------|-------------------|-----------------|\n| \"Make the code better\" | \"No TODO comments remain in src/\" | Grep-verifiable |\n| \"Add some docs\" | \"Every exported function has JSDoc with @param and @returns\" | Checkable by reading code |\n| \"Handle errors\" | \"Every async function has try/catch that sends a proper HTTP status\" | Pattern-matchable |\n| \"Clean up the code\" | \"No console.log statements and no var declarations remain\" | Searchable |\n\n## Categories of Good Promises\n\n- **Code quality**: \"No TODO comments remain\" — verify with grep\n- **Test-based**: \"All tests pass\" — verify by running npm test\n- **Structural**: \"Every module has an index.js\" — verify by checking files\n- **Documentation**: \"Every function has JSDoc\" — verify by reading code\n- **Standards**: \"ESLint reports zero warnings\" — verify by running linter\n\n## The --completion-promise Parameter\n\nDescribing completion criteria in your prompt text helps Claude know what to aim for, but Ralph Loop also needs a **mechanical signal** to know when to stop iterating. That's what `--completion-promise` does.\n\n```\n/ralph-loop:ralph-loop \"Your task description. When done, output <promise>DONE</promise>.\" --completion-promise \"DONE\"\n```\n\nHow it works:\n1. You choose a tag word (e.g., `DONE`, `COMPLETE`, `ALL_TODOS_FIXED`)\n2. You pass it as `--completion-promise \"TAG\"`\n3. You tell Claude in the prompt to output `<promise>TAG</promise>` when finished\n4. Ralph Loop checks Claude's output each iteration — when it finds the tag, the loop stops\n\n**Without `--completion-promise` or `--max-iterations`, a loop runs forever.** Always include at least one.\n\nYou can combine both for safety:\n```\n/ralph-loop:ralph-loop \"...\" --completion-promise \"DONE\" --max-iterations 10\n```\nThis stops when Claude signals completion OR after 10 iterations, whichever comes first.\n\n## Compound Promises\n\nFor complex tasks, combine multiple criteria:\n> Remove all TODO comments by implementing what each one asks for. Completion: (1) no file contains the string TODO, AND (2) config.js validates required env vars, AND (3) db.js has error handling, AND (4) helpers.js has JSDoc on all functions.\n\nClaude checks each condition. If any fails, it keeps working.\n\n## Your Exercise\n\nThis workspace has a project with **4 TODO comments** scattered across files. Each TODO describes a real improvement that needs implementing:\n\n- `src/config.js`: \"TODO: add validation\" — validate that required env vars exist\n- `src/db.js`: \"TODO: add error handling\" — wrap the DB connection in try/catch\n- `src/utils/helpers.js`: \"TODO: add JSDoc\" — add JSDoc comments to all functions\n- `src/app.js`: \"TODO: add graceful shutdown\" — handle SIGTERM signal\n\n**Use `/ralph-loop:ralph-loop` to eliminate ALL TODO comments by actually implementing what each one asks for.** Don't just delete the comments — implement the functionality.\n\n**Suggested invocation:**\n```\n/ralph-loop:ralph-loop \"Implement every TODO in this project, then remove the TODO comments. config.js: validate required env vars and throw if missing. db.js: wrap connection in try/catch. helpers.js: add JSDoc to all functions. app.js: handle SIGTERM for graceful shutdown. When all TODOs are implemented and removed, output <promise>ALL_TODOS_FIXED</promise>.\" --completion-promise \"ALL_TODOS_FIXED\" --max-iterations 10\n```\n\nNotice the compound completion criteria in the prompt text, plus `--completion-promise` to mechanically signal when done.\n\nAfter Ralph Loop completes, verify the TODOs are gone AND the implementations exist. Then run `/dojo check`.",
  "difficulty": "intermediate",
  "xpReward": 225,
  "estimatedMinutes": 15,
  "skills": ["completion-promises", "ralph-loop", "code-improvement"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-16-002",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Sample Express API\n\nA simple Express REST API with user and product endpoints.\n\n## Files\n\n- `src/app.js` — App setup and server startup\n- `src/config.js` — Configuration loading\n- `src/routes.js` — API route handlers\n- `src/db.js` — Database connection\n- `src/utils/helpers.js` — Utility functions\n"
      },
      {
        "path": "src/app.js",
        "content": "const express = require('express');\nconst { loadConfig } = require('./config');\nconst { setupRoutes } = require('./routes');\nconst { connectDB } = require('./db');\n\n// TODO: add graceful shutdown\nasync function startApp() {\n  const config = loadConfig();\n  const db = await connectDB(config.dbUrl);\n  const app = express();\n  setupRoutes(app, db);\n  app.listen(config.port);\n  return app;\n}\n\nmodule.exports = { startApp };\n"
      },
      {
        "path": "src/config.js",
        "content": "// TODO: add validation\nfunction loadConfig() {\n  return {\n    port: process.env.PORT || 3000,\n    dbUrl: process.env.DATABASE_URL || 'postgres://localhost/myapp',\n    secret: process.env.JWT_SECRET || 'dev-secret'\n  };\n}\n\nmodule.exports = { loadConfig };\n"
      },
      {
        "path": "src/routes.js",
        "content": "function setupRoutes(app, db) {\n  app.get('/api/users', async (req, res) => {\n    const users = await db.query('SELECT * FROM users');\n    res.json(users);\n  });\n\n  app.post('/api/users', async (req, res) => {\n    const { name, email } = req.body;\n    const user = await db.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email]);\n    res.status(201).json(user);\n  });\n\n  app.get('/api/products', async (req, res) => {\n    const products = await db.query('SELECT * FROM products');\n    res.json(products);\n  });\n\n  app.get('/api/products/:id', async (req, res) => {\n    const product = await db.query('SELECT * FROM products WHERE id = $1', [req.params.id]);\n    res.json(product);\n  });\n}\n\nmodule.exports = { setupRoutes };\n"
      },
      {
        "path": "src/db.js",
        "content": "// TODO: add error handling\nasync function connectDB(url) {\n  return {\n    query: async (sql, params) => {\n      // simulated database\n      return [];\n    }\n  };\n}\n\nmodule.exports = { connectDB };\n"
      },
      {
        "path": "src/utils/helpers.js",
        "content": "// TODO: add JSDoc\nfunction formatDate(date) {\n  return date.toISOString().split('T')[0];\n}\n\nfunction slugify(text) {\n  return text.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n}\n\nfunction truncate(str, len) {\n  if (str.length <= len) return str;\n  return str.substring(0, len) + '...';\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nmodule.exports = { formatDate, slugify, truncate, isEmpty };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "config.js has no TODO comments remaining",
      "type": "file_not_contains",
      "target": "src/config.js",
      "pattern": "TODO",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "db.js has no TODO comments remaining",
      "type": "file_not_contains",
      "target": "src/db.js",
      "pattern": "TODO",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "helpers.js has no TODO comments remaining",
      "type": "file_not_contains",
      "target": "src/utils/helpers.js",
      "pattern": "TODO",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "app.js has no TODO comments remaining",
      "type": "file_not_contains",
      "target": "src/app.js",
      "pattern": "TODO",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "config.js has actual validation (not just TODO removed)",
      "type": "file_contains",
      "target": "src/config.js",
      "pattern": "throw|Error|valid|required|!.*process\\.env",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "helpers.js has JSDoc comments (not just TODO removed)",
      "type": "file_contains",
      "target": "src/utils/helpers.js",
      "pattern": "/\\*\\*",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "db.js has real error handling (try/catch around connection)",
      "type": "file_contains",
      "target": "src/db.js",
      "pattern": "try|catch|error",
      "xpBonus": 30
    },
    {
      "id": "bonus-2",
      "description": "app.js handles SIGTERM for graceful shutdown",
      "type": "file_contains",
      "target": "src/app.js",
      "pattern": "SIGTERM|SIGINT|graceful|shutdown|process\\.on",
      "xpBonus": 30
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Read each file to see what the TODO comments ask for. Then craft a /ralph-loop:ralph-loop prompt with a compound completion promise: no TODOs remain AND each improvement is implemented.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "A good completion promise for this task lists each expected implementation: 'config.js validates env vars, db.js has try/catch, helpers.js has JSDoc, app.js handles SIGTERM, and no file contains the string TODO.' Pass --completion-promise \"ALL_TODOS_FIXED\" and tell Claude to output <promise>ALL_TODOS_FIXED</promise> when done.",
      "xpCost": 45
    },
    {
      "level": 3,
      "text": "Use: /ralph-loop:ralph-loop \"Implement every TODO in this project: (1) config.js: validate DATABASE_URL and JWT_SECRET exist, throw Error if missing. (2) db.js: wrap connectDB in try/catch. (3) helpers.js: add JSDoc with @param and @returns to all 4 functions. (4) app.js: add process.on(SIGTERM) for graceful shutdown. Remove all TODO comments after implementing. When done, output <promise>ALL_TODOS_FIXED</promise>.\" --completion-promise \"ALL_TODOS_FIXED\" --max-iterations 10",
      "xpCost": 90
    }
  ],

  "solution": {
    "approach": "Use /ralph-loop:ralph-loop with a compound completion promise that lists each TODO's required implementation AND the removal of all TODO comments. Ralph Loop implements each one and verifies both the implementation and the removal.",
    "example": "Invoke /ralph-loop:ralph-loop with a prompt that lists each TODO, what to implement, and tells Claude to output <promise>ALL_TODOS_FIXED</promise> when done. Pass --completion-promise \"ALL_TODOS_FIXED\" --max-iterations 10.",
    "alternativeApproaches": [
      "Run /ralph-loop:ralph-loop once per file, with a focused prompt and promise for each TODO",
      "Manually implement each TODO and remove the comments"
    ]
  },

  "learningPoints": [
    "Completion promises must be measurable — 'Can Claude verify this without human judgment?'",
    "Good promises are grep-verifiable, command-runnable, or code-readable",
    "Use --completion-promise \"TAG\" so Ralph Loop mechanically stops when Claude outputs <promise>TAG</promise>",
    "Compound promises combine multiple criteria (all must be true for the loop to stop)",
    "Always include --completion-promise or --max-iterations — without one, loops run forever",
    "Don't just delete TODOs — implement them. A good promise checks for both removal and implementation"
  ],

  "nextChallenge": "16-003"
}
