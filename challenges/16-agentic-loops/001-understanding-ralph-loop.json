{
  "id": "16-001",
  "module": "agentic-loops",
  "title": "Your First Ralph Loop",
  "description": "Learn what Ralph Loop is and use it to add error handling to a real Express project.\n\n## What Is Ralph Loop?\n\nRalph Loop is Claude Code's **agentic loop mode** — a way to have Claude work autonomously on a task until it meets your defined completion criteria. You invoke it with the `/ralph-loop:ralph-loop` command.\n\nIn normal Claude Code usage, you operate in a **human-in-the-loop** pattern: you send a prompt, Claude responds, you review, you decide what's next. Every step requires your input.\n\nRalph Loop flips this to an **agent-in-the-loop** pattern: you define the task and what \"done\" looks like, and Claude works autonomously — planning, executing, verifying, and iterating — until the completion criteria are met.\n\n| Aspect | Normal Mode | Ralph Loop |\n|--------|-------------|------------|\n| Control | You decide next step | Claude decides next step |\n| Interaction | Prompt -> Response -> Review | Define task -> Claude works -> Done |\n| Stops when | You stop prompting | Completion criteria are met |\n| Best for | Exploratory work, decisions | Repetitive, well-defined tasks |\n\n## The Two Parts of Every Ralph Loop\n\n1. **Task description**: What you want Claude to do. Be specific and actionable.\n2. **Completion promise**: What \"done\" looks like. Must be measurable — something Claude can verify by reading code, running commands, or searching files.\n3. **Stopping parameter**: Either `--max-iterations N` (stops after N iterations) or `--completion-promise \"TAG\"` (stops when Claude outputs `<promise>TAG</promise>`). **Without one of these, the loop runs forever.**\n\n**Example of a good prompt:**\n> Add try/catch to every async function in src/services/. Each catch should log the error and re-throw. Completion: every async function has try/catch and no unhandled await exists.\n\n**Cancelling a loop:** If you need to stop a running loop, use `/ralph-loop:cancel-ralph`.\n\n## Your Exercise\n\nThis workspace contains a small Express API project. The file `src/routes.js` has **4 async route handlers**, and none of them have error handling. If any database call fails, the server crashes with an unhandled promise rejection.\n\n**Use `/ralph-loop:ralph-loop` to add try/catch error handling to ALL async route handlers in `src/routes.js`.**\n\nSuggested invocation:\n```\n/ralph-loop:ralph-loop \"Add try/catch to every async route handler in src/routes.js. Each catch block should send a 500 status with a JSON error message. When done, output <promise>DONE</promise>.\" --completion-promise \"DONE\" --max-iterations 5\n```\n\nThis uses both `--completion-promise` (stops when Claude confirms it's done) and `--max-iterations 5` (safety net — stops after 5 iterations even if the promise isn't met).\n\nAfter Ralph Loop completes, read `src/routes.js` to verify all 4 handlers have proper error handling. Then run `/dojo check` to validate.",
  "difficulty": "intermediate",
  "xpReward": 200,
  "estimatedMinutes": 15,
  "skills": ["agentic-loops", "ralph-loop", "error-handling"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-16-001",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Sample Express API\n\nA simple Express REST API with user and product endpoints.\n\n## Files\n\n- `src/app.js` — App setup and server startup\n- `src/config.js` — Configuration loading\n- `src/routes.js` — API route handlers (4 endpoints)\n- `src/db.js` — Database connection\n- `src/utils/helpers.js` — Utility functions\n"
      },
      {
        "path": "src/app.js",
        "content": "const express = require('express');\nconst { loadConfig } = require('./config');\nconst { setupRoutes } = require('./routes');\nconst { connectDB } = require('./db');\n\nasync function startApp() {\n  const config = loadConfig();\n  const db = await connectDB(config.dbUrl);\n  const app = express();\n  setupRoutes(app, db);\n  app.listen(config.port);\n  return app;\n}\n\nmodule.exports = { startApp };\n"
      },
      {
        "path": "src/config.js",
        "content": "function loadConfig() {\n  return {\n    port: process.env.PORT || 3000,\n    dbUrl: process.env.DATABASE_URL || 'postgres://localhost/myapp',\n    secret: process.env.JWT_SECRET || 'dev-secret'\n  };\n}\n\nmodule.exports = { loadConfig };\n"
      },
      {
        "path": "src/routes.js",
        "content": "function setupRoutes(app, db) {\n  app.get('/api/users', async (req, res) => {\n    const users = await db.query('SELECT * FROM users');\n    res.json(users);\n  });\n\n  app.post('/api/users', async (req, res) => {\n    const { name, email } = req.body;\n    const user = await db.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email]);\n    res.status(201).json(user);\n  });\n\n  app.get('/api/products', async (req, res) => {\n    const products = await db.query('SELECT * FROM products');\n    res.json(products);\n  });\n\n  app.get('/api/products/:id', async (req, res) => {\n    const product = await db.query('SELECT * FROM products WHERE id = $1', [req.params.id]);\n    res.json(product);\n  });\n}\n\nmodule.exports = { setupRoutes };\n"
      },
      {
        "path": "src/db.js",
        "content": "async function connectDB(url) {\n  return {\n    query: async (sql, params) => {\n      // simulated database\n      return [];\n    }\n  };\n}\n\nmodule.exports = { connectDB };\n"
      },
      {
        "path": "src/utils/helpers.js",
        "content": "function formatDate(date) {\n  return date.toISOString().split('T')[0];\n}\n\nfunction slugify(text) {\n  return text.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n}\n\nfunction truncate(str, len) {\n  if (str.length <= len) return str;\n  return str.substring(0, len) + '...';\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nmodule.exports = { formatDate, slugify, truncate, isEmpty };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "routes.js contains try blocks (error handling was added)",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "try\\s*\\{",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "routes.js contains catch blocks",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "catch",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Error responses send 500 status code",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "status\\(500\\)",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "All 4 original route endpoints are preserved",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "/api/users|/api/products",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Error responses include meaningful messages (not empty catch blocks)",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "error\\.message|err\\.message|[Ii]nternal [Ss]erver|[Ss]erver [Ee]rror|[Ss]omething went wrong",
      "xpBonus": 40
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Type `/ralph-loop:ralph-loop` followed by your prompt in quotes. The description above has a suggested prompt you can use.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "Run: /ralph-loop:ralph-loop \"Add try/catch to every async route handler in src/routes.js. Each catch block should send a 500 status with a JSON error message like { error: 'Internal server error' }. When done, output <promise>DONE</promise>.\" --completion-promise \"DONE\" --max-iterations 5",
      "xpCost": 40
    },
    {
      "level": 3,
      "text": "You can also do this manually without Ralph Loop: open src/routes.js, wrap the body of each async (req, res) => { ... } handler in try { ... } catch (error) { res.status(500).json({ error: error.message }); }. There are 4 handlers to wrap.",
      "xpCost": 80
    }
  ],

  "solution": {
    "approach": "Use /ralph-loop:ralph-loop with a clear task (add try/catch to route handlers) and completion promise (every handler wrapped, 500 status on error). Ralph Loop will read routes.js, wrap each handler, and verify the changes.",
    "example": "Invoke /ralph-loop:ralph-loop \"Add try/catch to every async route handler in src/routes.js. Each catch block should send res.status(500).json({ error: error.message }). When done, output <promise>DONE</promise>.\" --completion-promise \"DONE\" --max-iterations 5",
    "alternativeApproaches": [
      "Manually edit routes.js to add try/catch to each of the 4 handlers",
      "Use /ralph-loop:ralph-loop with a broader scope that also covers app.js and db.js"
    ]
  },

  "learningPoints": [
    "Ralph Loop is invoked with /ralph-loop:ralph-loop and works autonomously until completion criteria are met",
    "Normal mode is human-in-the-loop; Ralph Loop is agent-in-the-loop",
    "Every Ralph Loop needs a task description (what to do), a completion promise (what done looks like), and a stopping parameter (--completion-promise or --max-iterations)",
    "Without --completion-promise or --max-iterations, a Ralph Loop runs forever — always include at least one",
    "Use /ralph-loop:cancel-ralph to cleanly stop a running loop",
    "Ralph Loop is best for repetitive, well-defined tasks like adding error handling across multiple handlers"
  ],

  "nextChallenge": "16-002"
}
