{
  "id": "16-001",
  "module": "agentic-loops",
  "title": "Understanding Ralph Loop",
  "description": "Learn what Ralph Loop is, how it differs from normal Claude Code interaction, and when autonomous agentic loops are the right tool for the job.",
  "difficulty": "intermediate",
  "xpReward": 200,
  "estimatedMinutes": 15,
  "skills": ["agentic-loops", "autonomous-work", "ralph-loop"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-16-001",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Understanding Ralph Loop\n\nLearn what Ralph Loop is, how it works, and when to use it.\n\n---\n\n## What Is Ralph Loop?\n\nRalph Loop is Claude Code's **agentic loop mode** -- a way to have Claude\nwork autonomously on a task until it meets your defined completion criteria.\nYou invoke it with `/ralph` or the `ralph-loop` skill.\n\nIn normal Claude Code usage, you operate in a **human-in-the-loop** pattern:\nyou send a prompt, Claude responds, you review the output, and then you\ndecide what to do next. Every step requires your input and judgment.\n\nRalph Loop flips this to an **agent-in-the-loop** pattern: you define the\ntask and tell Claude what \"done\" looks like, and Claude works autonomously\nthrough the task -- planning, executing, verifying, and iterating -- until\nthe completion criteria are met or you stop it.\n\n## Normal Mode vs Ralph Loop: A Comparison\n\n| Aspect                | Normal Claude Code         | Ralph Loop                       |\n|-----------------------|---------------------------|----------------------------------|\n| **Control flow**      | Human decides next step    | Claude decides next step         |\n| **Interaction**       | Prompt -> Response -> Review | Define task -> Claude works -> Done |\n| **When it stops**     | When you stop prompting    | When completion criteria are met |\n| **Human involvement** | Every step                 | Only at start and end            |\n| **Best for**          | Exploratory work, decisions | Repetitive, well-defined tasks   |\n| **Invocation**        | Normal prompting           | `/ralph` or `ralph-loop` skill   |\n\n## The Anatomy of a Ralph Loop\n\nEvery Ralph Loop has two essential parts:\n\n1. **Task Description**: What you want Claude to do. This should be specific\n   and actionable. \"Add error handling to all service files\" is good.\n   \"Make the code better\" is not.\n\n2. **Completion Promise**: A measurable definition of what \"done\" means.\n   This is how Claude knows when to stop iterating. \"Every async function\n   has try/catch and every error is logged with context\" is a good promise.\n   \"The code looks nice\" is not.\n\nClaude's iteration cycle inside a Ralph Loop looks like this:\n\n```\nPlan -> Execute -> Verify -> (criteria met? stop : identify gap -> fix -> verify again)\n```\n\nAt each step, Claude uses its full set of tools: reading files, writing code,\nrunning commands, searching the codebase. The key difference from normal mode\nis that Claude drives the cycle autonomously rather than waiting for you.\n\n## Completion Promises\n\nCompletion promises are the heart of Ralph Loop. They must be **measurable**\nand **verifiable**. Claude checks these after each iteration to determine\nwhether to continue or stop.\n\nExamples of good completion promises:\n- \"All tests pass\" (Claude can run tests to verify)\n- \"No TODO comments remain in src/\" (Claude can search for TODOs)\n- \"Every file in src/services/ has error handling\" (Claude can read each file)\n- \"ESLint reports zero warnings\" (Claude can run the linter)\n\nExamples of poor completion promises:\n- \"The code is clean\" (unmeasurable -- what does \"clean\" mean?)\n- \"Improve performance\" (no way to verify without benchmarks)\n- \"Make it production-ready\" (too vague and subjective)\n\n## When to Use Ralph Loop\n\nRalph Loop excels at tasks that are:\n- **Repetitive across files**: Apply the same change to 10+ files\n- **Iterative**: Tasks where you try, verify, fix, and try again\n- **Well-defined**: Clear criteria for what \"done\" means\n- **Self-contained**: Claude can verify completion without human judgment\n\nReal use cases:\n1. Adding JSDoc comments to every public function in a project\n2. Migrating a codebase from CommonJS to ES modules\n3. Adding error handling to all async functions\n4. Renaming a pattern consistently across many files\n5. Writing tests until coverage reaches a threshold\n6. Fixing all linter warnings in a project\n\n## When NOT to Use Ralph Loop\n\nRalph Loop is the wrong tool when:\n- **You need human judgment at each step**: Code review, architecture decisions\n- **The task is exploratory**: You don't know what \"done\" looks like yet\n- **It's a quick one-off task**: Simple file edits, single questions\n- **Results are subjective**: \"Make the UI look better\"\n- **The scope is too broad**: \"Refactor everything\" with no clear criteria\n\n## Safety and Control\n\nYou always remain in control during a Ralph Loop:\n- **Cancel anytime**: Use Ctrl+C or `/cancel` to stop the loop\n- **Claude asks before destructive actions**: Deleting files, force-pushing\n- **Transparent progress**: You can see what Claude is doing at each step\n- **Bounded scope**: Claude works within the scope you define\n\n## How Ralph Loop Uses Tools\n\nInside a Ralph Loop, Claude uses the same tools it always has -- Read, Write,\nEdit, Bash, Glob, Grep -- but it chains them together autonomously:\n\n1. **Plan**: Analyze the task, identify all files to change\n2. **Execute**: Make changes to each file\n3. **Verify**: Run tests, check output, search for remaining issues\n4. **Iterate**: If verification fails, identify what's wrong and fix it\n5. **Complete**: When all criteria pass, report what was done\n\n---\n\n## Your Task\n\nCreate a file called `ralph-loop-guide.md` that demonstrates your understanding\nof Ralph Loop. Your guide should cover:\n\n1. What Ralph Loop is and how it works\n2. How it differs from normal Claude Code interaction (human-in-the-loop vs agent-in-the-loop)\n3. What completion promises are and why they matter\n4. At least 3 real use cases where Ralph Loop is the right tool\n5. When NOT to use Ralph Loop\n\nUse the sample project files in this workspace as context when thinking about\nuse cases -- imagine what Ralph Loop tasks you might run on this codebase.\n"
      },
      {
        "path": "src/app.js",
        "content": "const express = require('express');\nconst { loadConfig } = require('./config');\nconst { setupRoutes } = require('./routes');\nconst { connectDB } = require('./db');\n\nasync function startApp() {\n  const config = loadConfig();\n  const db = await connectDB(config.dbUrl);\n  const app = express();\n  setupRoutes(app, db);\n  app.listen(config.port);\n  return app;\n}\n\nmodule.exports = { startApp };\n"
      },
      {
        "path": "src/config.js",
        "content": "// TODO: add validation\nfunction loadConfig() {\n  return {\n    port: process.env.PORT || 3000,\n    dbUrl: process.env.DATABASE_URL || 'postgres://localhost/myapp',\n    secret: process.env.JWT_SECRET || 'dev-secret'\n  };\n}\n\nmodule.exports = { loadConfig };\n"
      },
      {
        "path": "src/routes.js",
        "content": "function setupRoutes(app, db) {\n  app.get('/api/users', async (req, res) => {\n    const users = await db.query('SELECT * FROM users');\n    res.json(users);\n  });\n\n  app.post('/api/users', async (req, res) => {\n    const { name, email } = req.body;\n    const user = await db.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email]);\n    res.status(201).json(user);\n  });\n\n  app.get('/api/products', async (req, res) => {\n    const products = await db.query('SELECT * FROM products');\n    res.json(products);\n  });\n\n  app.get('/api/products/:id', async (req, res) => {\n    const product = await db.query('SELECT * FROM products WHERE id = $1', [req.params.id]);\n    res.json(product);\n  });\n}\n\nmodule.exports = { setupRoutes };\n"
      },
      {
        "path": "src/db.js",
        "content": "// TODO: add error handling\nasync function connectDB(url) {\n  return {\n    query: async (sql, params) => {\n      // simulated database\n      return [];\n    }\n  };\n}\n\nmodule.exports = { connectDB };\n"
      },
      {
        "path": "src/utils/helpers.js",
        "content": "// TODO: add JSDoc\nfunction formatDate(date) {\n  return date.toISOString().split('T')[0];\n}\n\nfunction slugify(text) {\n  return text.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n}\n\nfunction truncate(str, len) {\n  if (str.length <= len) return str;\n  return str.substring(0, len) + '...';\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nmodule.exports = { formatDate, slugify, truncate, isEmpty };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create ralph-loop-guide.md",
      "type": "file_exists",
      "target": "ralph-loop-guide.md",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Guide explains what Ralph Loop is and how it works (agentic loop, autonomous work)",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "[Aa]gentic.*[Ll]oop|[Aa]utonomous|[Rr]alph [Ll]oop.*is|[Rr]alph [Ll]oop.*works",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Guide contrasts Ralph Loop with normal Claude Code interaction (human-in-the-loop vs agent-in-the-loop)",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "human.in.the.loop|agent.in.the.loop|normal.*[Cc]laude|[Dd]iffer|[Cc]ompar|vs\\b",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Guide explains completion promises -- measurable criteria for when to stop",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "[Cc]ompletion.*[Pp]romise|[Cc]ompletion.*[Cc]riteri|[Mm]easurable|when.*done|when.*stop",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Guide includes at least 3 real use cases for Ralph Loop",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "[Uu]se case|[Ss]cenario|[Pp]erfect for|[Gg]reat for|[Ii]deal for|[Ee]xample",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "Guide explains when NOT to use Ralph Loop",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "[Nn]ot.*use|[Aa]void|[Ww]rong tool|[Ss]houldn.t|[Dd]on.t use|[Ww]hen not",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Guide references specific files from the sample project as example Ralph Loop targets",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "routes\\.js|helpers\\.js|db\\.js|config\\.js|TODO",
      "xpBonus": 30
    },
    {
      "id": "bonus-2",
      "description": "Guide discusses safety and control (cancel, Ctrl+C, destructive action warnings)",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "[Cc]ancel|[Ss]top|[Cc]trl|[Ss]afety|[Cc]ontrol|[Dd]estructive",
      "xpBonus": 30
    },
    {
      "id": "bonus-3",
      "description": "Guide explains how to invoke Ralph Loop (/ralph or ralph-loop skill)",
      "type": "file_contains",
      "target": "ralph-loop-guide.md",
      "pattern": "/ralph|ralph.loop.*skill|invoke|start.*loop",
      "xpBonus": 20
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Read the README thoroughly -- it contains all the conceptual material you need. Think about what makes Ralph Loop different from just sending multiple prompts in a row. What role do completion promises play?",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "Structure your guide around these sections: What It Is, How It Differs From Normal Mode, Completion Promises, Use Cases, When Not To Use It. Look at the sample project files for concrete examples of tasks that would benefit from Ralph Loop (like adding error handling to all those async routes).",
      "xpCost": 40
    },
    {
      "level": 3,
      "text": "Create ralph-loop-guide.md with these sections: 1) Definition: Ralph Loop is an agentic loop invoked via /ralph, enabling autonomous iterative work. 2) Comparison: human-in-the-loop (normal) vs agent-in-the-loop (Ralph). 3) Completion promises: measurable criteria like 'all tests pass' or 'no TODOs remain'. 4) Use cases: adding JSDoc to helpers.js, error handling in routes.js, fixing TODOs in db.js and config.js. 5) When NOT to use: exploratory work, subjective tasks, quick one-off edits.",
      "xpCost": 80
    }
  ],

  "solution": {
    "approach": "Study the README's explanation of Ralph Loop, then create a comprehensive guide demonstrating understanding of agentic loops, completion promises, and appropriate use cases.",
    "example": "Create ralph-loop-guide.md covering: definition, comparison with normal mode, completion promises, real use cases referencing the sample project, and when to avoid Ralph Loop.",
    "alternativeApproaches": [
      "Ask Claude to explain Ralph Loop while examining the sample codebase for concrete examples",
      "Build the guide incrementally, section by section, verifying each concept"
    ]
  },

  "learningPoints": [
    "Ralph Loop is Claude Code's agentic loop mode, invoked with /ralph or the ralph-loop skill",
    "Normal mode is human-in-the-loop (you drive); Ralph Loop is agent-in-the-loop (Claude drives)",
    "Every Ralph Loop needs a task description and a completion promise (measurable done criteria)",
    "Ralph Loop excels at repetitive, well-defined tasks across many files",
    "Ralph Loop is wrong for exploratory work, subjective tasks, or quick one-off edits",
    "You can always cancel a Ralph Loop with Ctrl+C or /cancel"
  ],

  "nextChallenge": "16-002"
}
