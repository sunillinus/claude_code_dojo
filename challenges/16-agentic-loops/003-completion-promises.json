{
  "id": "16-003",
  "module": "agentic-loops",
  "title": "Multi-Phase Loops",
  "description": "Learn when a single Ralph Loop isn't enough, and practice running sequential loops to make ordered improvements to a codebase.\n\n## When One Loop Isn't Enough\n\nSome tasks are too complex for a single Ralph Loop. When you throw too much at one loop:\n- Claude loses focus after many iterations\n- Broad completion criteria are hard to verify\n- Early changes might conflict with later changes\n- If something goes wrong, you lose all progress\n\nThe solution: break complex work into **ordered phases**, each with its own focused Ralph Loop.\n\n## Phase Dependencies\n\nOrder matters. Consider this task: \"Add JSDoc to all functions, then add input validation that references the documented parameter types.\"\n\nPhase 2 (validation) depends on Phase 1 (JSDoc) being done first — the validation logic references the parameter types that JSDoc documents. Running them in the wrong order means Phase 2 can't reference types that don't exist yet.\n\n**Rule of thumb:** If Phase B reads or builds on what Phase A creates, run A first.\n\n## The Multi-Phase Pattern\n\n1. **Run Phase 1** with `/ralph-loop:ralph-loop` — focused task + completion promise\n2. **Verify Phase 1** — read the files, confirm it looks right\n3. **Run Phase 2** with `/ralph-loop:ralph-loop` — next task + completion promise\n4. **Verify Phase 2** — confirm everything works together\n\n## When to Split vs Keep in One Loop\n\n| Keep in one loop | Split into phases |\n|------------------|-------------------|\n| Same type of change across files | Different types of changes |\n| No dependencies between changes | Later changes depend on earlier ones |\n| Simple, mechanical changes | Complex changes needing verification |\n| < 10 iterations expected | 10+ iterations expected |\n\n## Your Exercise\n\nThis project needs TWO distinct improvements, and they must be done in order:\n\n**Phase 1: Add JSDoc documentation** to every exported function across all files (`src/routes.js`, `src/db.js`, `src/utils/helpers.js`). Each function should have `@param` and `@returns` tags.\n\n**Phase 2: Add input validation** to the route handlers in `src/routes.js`. Validate that required fields exist in request body/params before using them. Return 400 status for bad input.\n\nPhase 2 depends on Phase 1 — the validation logic can reference the documented parameter types from JSDoc.\n\n**Run `/ralph-loop:ralph-loop` twice — once per phase:**\n\nPhase 1 prompt:\n> Add JSDoc comments with @param and @returns to every exported function in src/routes.js, src/db.js, and src/utils/helpers.js. Completion: every exported function has a JSDoc block with @param for each parameter and @returns describing the return value.\n\nVerify Phase 1, then Phase 2 prompt:\n> Add input validation to route handlers in src/routes.js. For POST/PUT endpoints, validate that required fields (name, email) exist in req.body. For :id params, validate the id. Return 400 status with an error message for invalid input. Completion: every route that accepts input validates it before use, and returns 400 for missing/invalid data.\n\nRun `/dojo check` after both phases complete.",
  "difficulty": "advanced",
  "xpReward": 275,
  "estimatedMinutes": 20,
  "skills": ["multi-phase-loops", "ralph-loop", "sequential-tasks"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-16-003",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Sample Express API\n\nA simple Express REST API with user and product endpoints.\n\n## Files\n\n- `src/app.js` — App setup and server startup\n- `src/config.js` — Configuration loading\n- `src/routes.js` — API route handlers (4 endpoints, no validation)\n- `src/db.js` — Database connection\n- `src/utils/helpers.js` — Utility functions (no documentation)\n"
      },
      {
        "path": "src/app.js",
        "content": "const express = require('express');\nconst { loadConfig } = require('./config');\nconst { setupRoutes } = require('./routes');\nconst { connectDB } = require('./db');\n\nasync function startApp() {\n  const config = loadConfig();\n  const db = await connectDB(config.dbUrl);\n  const app = express();\n  app.use(express.json());\n  setupRoutes(app, db);\n  app.listen(config.port);\n  return app;\n}\n\nmodule.exports = { startApp };\n"
      },
      {
        "path": "src/config.js",
        "content": "function loadConfig() {\n  return {\n    port: process.env.PORT || 3000,\n    dbUrl: process.env.DATABASE_URL || 'postgres://localhost/myapp',\n    secret: process.env.JWT_SECRET || 'dev-secret'\n  };\n}\n\nmodule.exports = { loadConfig };\n"
      },
      {
        "path": "src/routes.js",
        "content": "function setupRoutes(app, db) {\n  app.get('/api/users', async (req, res) => {\n    const users = await db.query('SELECT * FROM users');\n    res.json(users);\n  });\n\n  app.post('/api/users', async (req, res) => {\n    const { name, email } = req.body;\n    const user = await db.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email]);\n    res.status(201).json(user);\n  });\n\n  app.get('/api/products', async (req, res) => {\n    const products = await db.query('SELECT * FROM products');\n    res.json(products);\n  });\n\n  app.get('/api/products/:id', async (req, res) => {\n    const product = await db.query('SELECT * FROM products WHERE id = $1', [req.params.id]);\n    res.json(product);\n  });\n}\n\nmodule.exports = { setupRoutes };\n"
      },
      {
        "path": "src/db.js",
        "content": "async function connectDB(url) {\n  return {\n    query: async (sql, params) => {\n      // simulated database\n      return [];\n    }\n  };\n}\n\nmodule.exports = { connectDB };\n"
      },
      {
        "path": "src/utils/helpers.js",
        "content": "function formatDate(date) {\n  return date.toISOString().split('T')[0];\n}\n\nfunction slugify(text) {\n  return text.toLowerCase().replace(/\\s+/g, '-').replace(/[^a-z0-9-]/g, '');\n}\n\nfunction truncate(str, len) {\n  if (str.length <= len) return str;\n  return str.substring(0, len) + '...';\n}\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nmodule.exports = { formatDate, slugify, truncate, isEmpty };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "helpers.js has JSDoc comments (@param or @returns)",
      "type": "file_contains",
      "target": "src/utils/helpers.js",
      "pattern": "@param|@returns|@function",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "routes.js has JSDoc comments on route setup or handlers",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "@param|@returns|/\\*\\*",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "db.js has JSDoc comments",
      "type": "file_contains",
      "target": "src/db.js",
      "pattern": "@param|@returns|/\\*\\*",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "routes.js has input validation (checking for required fields)",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "if\\s*\\(!|validate|!.*name|!.*email|!req\\.body|!req\\.params",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "routes.js returns 400 status for invalid input",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "400|[Bb]ad [Rr]equest|[Mm]issing|[Rr]equired",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "config.js also has JSDoc documentation",
      "type": "file_contains",
      "target": "src/config.js",
      "pattern": "@param|@returns|/\\*\\*",
      "xpBonus": 30
    },
    {
      "id": "bonus-2",
      "description": "Routes validate :id parameter format (not just body fields)",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "params\\.id|isNaN|parseInt|Number",
      "xpBonus": 30
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "This is a two-phase task. Run /ralph-loop:ralph-loop first for JSDoc (Phase 1), verify the results, then run /ralph-loop:ralph-loop again for input validation (Phase 2). The description has suggested prompts for each phase.",
      "xpCost": 20
    },
    {
      "level": 2,
      "text": "Phase 1 prompt: 'Add JSDoc with @param and @returns to every exported function in src/routes.js, src/db.js, and src/utils/helpers.js. Completion: every exported function has JSDoc.' After Phase 1 completes, read the files to verify. Then Phase 2: 'Add input validation to POST and parameterized GET routes in src/routes.js. Validate required body fields and params. Return 400 for invalid input. Completion: every route that takes input validates it.'",
      "xpCost": 55
    },
    {
      "level": 3,
      "text": "If /ralph-loop:ralph-loop isn't available, do it manually. Phase 1: Add /** @param {type} name - description \\n @returns {type} description */ before each exported function in routes.js, db.js, and helpers.js. Phase 2: In routes.js POST /api/users handler, add: if (!name || !email) return res.status(400).json({ error: 'Missing required fields: name, email' }); In GET /api/products/:id, validate the id parameter.",
      "xpCost": 110
    }
  ],

  "solution": {
    "approach": "Run two sequential Ralph Loops. Phase 1 adds JSDoc to all exported functions. Verify, then Phase 2 adds input validation to route handlers. Each phase has focused scope and measurable completion criteria.",
    "example": "Phase 1: /ralph-loop:ralph-loop 'Add JSDoc to all functions. Completion: every function has @param and @returns.' Phase 2: /ralph-loop:ralph-loop 'Add validation to routes. Completion: POST routes check body fields, GET :id routes check params, 400 returned for invalid input.'",
    "alternativeApproaches": [
      "Combine both into a single Ralph Loop with compound promises (riskier but faster)",
      "Do JSDoc and validation manually without Ralph Loop"
    ]
  },

  "learningPoints": [
    "Complex tasks should be broken into multiple focused Ralph Loop phases",
    "Phase ordering matters — if Phase B depends on Phase A's output, run A first",
    "Verify between phases to catch problems before building on them",
    "Each phase needs its own focused completion promise",
    "Splitting into phases gives you checkpoints — if Phase 2 fails, Phase 1's work is preserved"
  ],

  "nextChallenge": "16-004"
}
