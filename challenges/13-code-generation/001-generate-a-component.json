{
  "id": "13-001",
  "module": "code-generation",
  "title": "Generate a Component",
  "description": "Learn to generate code that matches existing project conventions by describing behavior, interface contracts, and style expectations. Good generation starts with good descriptions.",
  "difficulty": "beginner",
  "xpReward": 150,
  "estimatedMinutes": 15,
  "skills": ["component-generation", "convention-matching", "prompt-crafting", "code-review"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-13-001",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Generate a Component\n\nLearn to generate new code that matches existing project patterns using Claude Code.\n\n## What Is Code Generation?\n\nCode generation with Claude Code means asking it to create new code files\nfor you. But there is a huge difference between good generation and bad\ngeneration. The difference comes down to how well you describe what you want.\n\nConsider two developers asking for the same thing:\n\nDeveloper A: \"Create a comments module.\"\nDeveloper B: \"Create a comments module with three files (route, controller,\nservice) following the same pattern as the users module. A comment has\nbody (required string), userId (required string), and postId (required string).\nValidate required fields and return 400 for missing ones.\"\n\nDeveloper A gets something that works but probably does not match the\nproject conventions. Developer B gets code that fits right in. The\ndifference is not Claude Code's capability - it is the quality of the\ninstructions.\n\n## The Three Pillars of Good Generation Prompts\n\n### 1. Describe Behavior, Not Just Structure\n\nBad: \"Create a comments controller\"\nGood: \"Create a comments controller that handles CRUD operations, validates\nthat comment body is non-empty, and returns the associated user with each comment\"\n\nThe first prompt gives Claude Code freedom to invent behavior. The second\ntells it exactly what the code should DO. When you skip behavior description,\nyou are gambling that Claude Code will guess your intentions correctly.\nSometimes it will, but often the result will need rework.\n\n### 2. Provide Interface Contracts\n\nAn interface contract says: \"this function takes X and returns Y.\"\n\n```\nBad:  \"Create a function to process orders\"\nGood: \"Create a processOrder function that:\n       - Takes: { items: Array<{id, qty}>, userId: string, couponCode?: string }\n       - Returns: { orderId: string, total: number, status: 'confirmed' | 'failed' }\n       - Throws: InvalidItemError if any item ID doesn't exist\"\n```\n\nWith interface contracts, Claude Code knows the exact shape of inputs and\noutputs. This eliminates guessing. Interface contracts also make it easy\nto verify the generated code - you can check that the function signature\nmatches exactly what you specified.\n\n### 3. Match Project Conventions\n\nEvery codebase has conventions, whether documented or not:\n- Arrow functions vs function declarations\n- Error handling style (throw vs return error objects)\n- Import style (named vs default exports)\n- Response wrapping ({ data: result } vs bare result)\n- File naming (camelCase vs kebab-case)\n- File organization (one class per file, layered architecture, etc.)\n\nWhen you point Claude Code at existing code, it can match these conventions.\nThe key prompt pattern is:\n\n```\n\"Look at [existing file]. Create [new file] following the same pattern.\"\n```\n\nThis works because Claude Code reads the existing file, identifies the\npatterns, and replicates them. It is far more reliable than describing\nconventions in words because the code itself is the source of truth.\n\n## The Review Step\n\nNEVER accept generated code without reviewing it. Always:\n1. Read the generated code yourself\n2. Check it matches your conventions\n3. Verify the behavior is correct\n4. Look for edge cases that were missed\n5. Confirm imports and references point to real files\n\nThis is not a limitation of Claude Code - it is good engineering practice.\nGenerated code is a draft, not a final product. Even senior developers\nreview each other's code. Treat generated code with the same scrutiny.\n\n## What Makes a Generation Prompt Effective\n\n| Element | Bad Example | Good Example |\n|---------|-------------|-------------|\n| Inputs | \"takes some data\" | \"takes { userId: string, limit?: number }\" |\n| Outputs | \"returns results\" | \"returns Array<Comment> sorted by createdAt desc\" |\n| Errors | (not mentioned) | \"returns 404 if user not found, 400 if limit < 0\" |\n| Style | (not mentioned) | \"use arrow functions, named exports, like userRoutes.js\" |\n| Edge cases | (not mentioned) | \"handle empty arrays, null userId, limit of 0\" |\n\n## Anti-Patterns to Avoid\n\n1. **Generating without specifying behavior**: Leads to code that looks right\n   but does the wrong thing\n2. **Accepting without review**: Generated code may have subtle bugs,\n   incorrect imports, or logic that almost works\n3. **Not referencing existing code**: Results in inconsistent style that\n   creates maintenance burden for the team\n4. **Over-specifying implementation**: Say WHAT not HOW - let Claude Code\n   choose the implementation approach. Telling it which loop construct\n   to use or which variable names to pick is counter-productive.\n5. **Generating too much at once**: Start with one component, review it,\n   then generate the next. This catches problems early.\n\n## Identifying Conventions in Existing Code\n\nBefore you ask Claude Code to generate anything, spend a few minutes\nreading the existing code. Look for these patterns:\n\n- How are functions exported? (export const vs export default vs module.exports)\n- How are errors handled? (try/catch with next(err), or inline status codes)\n- What is the response format? ({ data: ... } wrapper, or bare objects)\n- How is validation done? (inline checks, or separate validator functions)\n- What is the naming pattern? (getAllUsers, not fetchUsers or listUsers)\n\nOnce you identify these patterns, mention them in your prompt or simply\npoint Claude Code at the files to read.\n\n## Your Exercise\n\nThis workspace contains an Express API with a `/api/users` resource.\nIt has a consistent pattern across three files:\n- `routes/userRoutes.js` - Route definitions with Router import and named export\n- `controllers/userController.js` - Request handlers as exported arrow functions\n- `services/userService.js` - Business logic with async functions\n\nStudy these files and notice the conventions:\n- Arrow function exports: `export const getAllUsers = async (req, res, next) => { ... }`\n- Error handling: try/catch blocks that call `next(err)` in the catch\n- Response wrapping: all successful responses use `{ data: result }`\n- 404 pattern: check if result is null, return `{ error: '... not found' }`\n- Validation: inline required field checks with 400 status responses\n\nYour task: Generate a new `/api/comments` resource that follows the\nexact same pattern. Study the existing files first, then ask Claude Code\nto generate the new resource matching those conventions.\n\n## Objectives\n1. Generate `routes/commentRoutes.js` following the userRoutes pattern\n2. Generate `controllers/commentController.js` following the controller pattern\n3. Generate `services/commentService.js` following the service pattern\n4. Ensure the generated code uses the same conventions (arrow functions,\n   error handling, named exports) as the existing code\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"express-api\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"uuid\": \"^9.0.0\"\n  }\n}"
      },
      {
        "path": "app.js",
        "content": "import express from 'express';\nimport { userRoutes } from './routes/userRoutes.js';\n\nconst app = express();\napp.use(express.json());\n\n// Mount routes\napp.use('/api/users', userRoutes);\n\n// Error handling middleware\napp.use((err, req, res, next) => {\n  const status = err.status || 500;\n  res.status(status).json({\n    error: err.message || 'Internal server error',\n    status\n  });\n});\n\nexport default app;\n"
      },
      {
        "path": "routes/userRoutes.js",
        "content": "import { Router } from 'express';\nimport {\n  getAllUsers,\n  getUserById,\n  createUser,\n  updateUser,\n  deleteUser\n} from '../controllers/userController.js';\n\nconst router = Router();\n\nrouter.get('/', getAllUsers);\nrouter.get('/:id', getUserById);\nrouter.post('/', createUser);\nrouter.put('/:id', updateUser);\nrouter.delete('/:id', deleteUser);\n\nexport { router as userRoutes };\n"
      },
      {
        "path": "controllers/userController.js",
        "content": "import * as userService from '../services/userService.js';\n\nexport const getAllUsers = async (req, res, next) => {\n  try {\n    const users = await userService.findAll();\n    res.json({ data: users });\n  } catch (err) {\n    next(err);\n  }\n};\n\nexport const getUserById = async (req, res, next) => {\n  try {\n    const user = await userService.findById(req.params.id);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    res.json({ data: user });\n  } catch (err) {\n    next(err);\n  }\n};\n\nexport const createUser = async (req, res, next) => {\n  try {\n    const { name, email } = req.body;\n    if (!name || !email) {\n      return res.status(400).json({ error: 'Name and email are required' });\n    }\n    const user = await userService.create({ name, email });\n    res.status(201).json({ data: user });\n  } catch (err) {\n    next(err);\n  }\n};\n\nexport const updateUser = async (req, res, next) => {\n  try {\n    const user = await userService.update(req.params.id, req.body);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    res.json({ data: user });\n  } catch (err) {\n    next(err);\n  }\n};\n\nexport const deleteUser = async (req, res, next) => {\n  try {\n    const deleted = await userService.remove(req.params.id);\n    if (!deleted) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    res.status(204).end();\n  } catch (err) {\n    next(err);\n  }\n};\n"
      },
      {
        "path": "services/userService.js",
        "content": "import { v4 as uuidv4 } from 'uuid';\n\nconst users = [];\n\nexport const findAll = async () => {\n  return users;\n};\n\nexport const findById = async (id) => {\n  return users.find((u) => u.id === id) || null;\n};\n\nexport const create = async (data) => {\n  const user = {\n    id: uuidv4(),\n    ...data,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  };\n  users.push(user);\n  return user;\n};\n\nexport const update = async (id, data) => {\n  const index = users.findIndex((u) => u.id === id);\n  if (index === -1) return null;\n  users[index] = {\n    ...users[index],\n    ...data,\n    updatedAt: new Date().toISOString()\n  };\n  return users[index];\n};\n\nexport const remove = async (id) => {\n  const index = users.findIndex((u) => u.id === id);\n  if (index === -1) return false;\n  users.splice(index, 1);\n  return true;\n};\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create routes/commentRoutes.js with route definitions",
      "type": "file_exists",
      "target": "routes/commentRoutes.js",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Comment routes follow the same Router pattern (Router import, named export)",
      "type": "file_contains",
      "target": "routes/commentRoutes.js",
      "pattern": "import.*Router.*from.*express|Router\\(\\)",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Create controllers/commentController.js with request handlers",
      "type": "file_exists",
      "target": "controllers/commentController.js",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Comment controller uses arrow function exports (matching project convention)",
      "type": "file_contains",
      "target": "controllers/commentController.js",
      "pattern": "export const .+ = async \\(req, res, next\\)",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Create services/commentService.js with business logic",
      "type": "file_exists",
      "target": "services/commentService.js",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "Comment service exports follow the same pattern (findAll, findById, create)",
      "type": "file_contains",
      "target": "services/commentService.js",
      "pattern": "export const (findAll|findById|create)",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "Controller uses try/catch with next(err) error handling (matching convention)",
      "type": "file_contains",
      "target": "controllers/commentController.js",
      "pattern": "catch.*\\{[\\s\\S]*?next\\(err\\)",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Controller validates required fields before creating a comment",
      "type": "file_contains",
      "target": "controllers/commentController.js",
      "pattern": "(!.*body|!.*text|!.*content|required|status\\(400\\))",
      "xpBonus": 30
    },
    {
      "id": "bonus-2",
      "description": "Comment routes are registered in app.js",
      "type": "file_contains",
      "target": "app.js",
      "pattern": "commentRoutes|/api/comments",
      "xpBonus": 30
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Before asking Claude Code to generate anything, study the three existing files: routes/userRoutes.js, controllers/userController.js, and services/userService.js. Notice the patterns: arrow function exports, try/catch with next(err), { data: result } response wrapping, named Router export. Your generation prompt should reference these files specifically.",
      "xpCost": 10
    },
    {
      "level": 2,
      "text": "Use a prompt like: 'Read routes/userRoutes.js, controllers/userController.js, and services/userService.js. Create the equivalent three files for a /api/comments resource following the exact same patterns. A comment has: body (required string), userId (required string), and postId (required string).' This gives Claude Code the interface contract AND points it at the conventions.",
      "xpCost": 30
    },
    {
      "level": 3,
      "text": "After generation, review the code: Does commentController use 'export const' arrow functions? Does it wrap responses in { data: ... }? Does the service use findAll/findById/create/update/remove? Does the route file import from Router and export as a named export? If anything is off, ask Claude Code to fix it to match the user files more closely. Then register the routes in app.js.",
      "xpCost": 60
    }
  ],

  "solution": {
    "approach": "Study existing user resource files to understand conventions, then ask Claude Code to generate the equivalent comment resource files referencing the existing patterns explicitly.",
    "example": "Read the three user resource files (routes, controller, service), then prompt: 'Using the user resource files as a template, generate routes/commentRoutes.js, controllers/commentController.js, and services/commentService.js for a comments resource. A comment has body, userId, and postId fields. Follow the exact same patterns.'",
    "alternativeApproaches": [
      "Generate one file at a time, reviewing each before moving to the next",
      "Describe the conventions explicitly in your prompt instead of referencing files",
      "Generate the service first (pure logic), then controller, then routes"
    ]
  },

  "learningPoints": [
    "Effective generation prompts describe behavior AND reference existing conventions",
    "Interface contracts (inputs, outputs, errors) eliminate ambiguity in generated code",
    "Always point Claude Code at existing files so it can match project style",
    "Review generated code for convention compliance before accepting it",
    "Saying WHAT the code should do is more important than saying HOW to implement it"
  ],

  "nextChallenge": "13-002"
}