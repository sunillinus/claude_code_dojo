{
  "id": "11-001",
  "module": "subagents",
  "title": "Use Explore Subagent",
  "description": "Learn what subagents are and use one to audit a multi-file project, then create a barrel file.\n\n## What Are Subagents?\n\nSubagents are specialized autonomous agents that Claude Code can spawn using the **Task tool**. Each subagent runs in its own context -- separate from your main conversation -- so it doesn't clutter your chat with excessive output.\n\nThink of subagents as specialists you can dispatch to handle specific jobs. They go off, do their work, and report back with results.\n\nKey properties of subagents:\n- Run in their own isolated context (protects your main conversation)\n- Have access to specific tools based on their type\n- Can run in foreground (blocking) or background (non-blocking)\n- Return results back to the main conversation when done\n\n## The 4 Built-in Subagent Types\n\n| Type | Purpose | Key Tools | Best For |\n|------|---------|-----------|----------|\n| **Explore** | Fast codebase search and exploration | Glob, Grep, Read (no Edit/Write) | Finding files, understanding structure, auditing |\n| **Bash** | Run shell commands | Bash only | Running tests, builds, scripts |\n| **Plan** | Design implementation plans | Read-only tools (no Edit/Write) | Architecture planning, step-by-step design |\n| **general-purpose** | Any complex multi-step task | All tools | Anything that needs reading AND writing |\n\n## How Subagents Protect Your Context\n\nClaude Code has a finite context window. When you ask it to explore a large codebase, the results (file contents, search matches, directory listings) consume that context. Subagents run in their **own** context window, so only the final summary comes back to your main conversation.\n\nWithout subagents: You ask Claude to read 20 files -> all 20 files fill your context -> less room for actual work.\n\nWith subagents: Explore agent reads 20 files in its own context -> sends back a concise summary -> your context stays clean.\n\n## When to Use Each Type\n\n- **Need to find something?** -> Explore (fastest, read-only, can't accidentally modify files)\n- **Need to run a command?** -> Bash (isolated command execution)\n- **Need to plan before building?** -> Plan (can research but can't modify, safe for exploration)\n- **Need everything?** -> general-purpose (full access, use when the task requires both reading and writing)\n\n## How to Request a Subagent\n\nYou don't call subagents directly -- you describe what you need and Claude Code decides when to use one. But you can guide it:\n\n- \"Use an explore agent to find all API endpoints in this project\"\n- \"Spawn a bash agent to run the test suite\"\n- \"Use a subagent to research how the auth system works\"\n\n## Your Exercise\n\nThis workspace contains a **9-file Express API project** spread across multiple directories: handlers, middleware, utils, and core modules. Understanding all the exports across these files manually would be tedious.\n\n**Your task: Use an Explore subagent to audit the project, then create a `src/index.js` barrel file that re-exports all public modules.**\n\nA barrel file is a single entry point that re-exports everything from a package, so consumers can do `const { getUsers, loadConfig, authenticate } = require('./src')` instead of importing from individual files.\n\nYour barrel file (`src/index.js`) should import and re-export from:\n- `./handlers/users` (user handler functions)\n- `./handlers/products` (product handler functions)\n- `./middleware/auth` (auth middleware)\n- `./db` (database connection)\n- `./config` (configuration)\n- `./server` (server creation)\n- `./utils/logger` (logging)\n\nSuggested approach:\n1. Ask Claude to \"use an explore agent to find all exported functions across all files in src/\"\n2. Review the findings\n3. Create `src/index.js` that re-exports everything\n\nRun `/dojo check` when done.",
  "difficulty": "intermediate",
  "xpReward": 225,
  "estimatedMinutes": 15,
  "skills": ["subagent-basics", "explore-agent", "barrel-files"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-11-001",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Express API Project\n\nA multi-file Express REST API with user and product endpoints, authentication middleware, database layer, and logging utilities.\n\n## Structure\n\n- `src/app.js` — App setup and startup\n- `src/config.js` — Configuration loading and validation\n- `src/server.js` — HTTP server creation and shutdown\n- `src/routes.js` — Route registration\n- `src/db.js` — Database connection\n- `src/handlers/users.js` — User route handlers\n- `src/handlers/products.js` — Product route handlers\n- `src/middleware/auth.js` — JWT authentication middleware\n- `src/utils/logger.js` — Logging utility\n"
      },
      {
        "path": "src/app.js",
        "content": "const express = require('express');\nconst { createServer } = require('./server');\nconst { loadConfig } = require('./config');\nconst { setupRoutes } = require('./routes');\nconst { connectDatabase } = require('./db');\nconst { initLogger } = require('./utils/logger');\n\nasync function startApp() {\n  const config = loadConfig();\n  const logger = initLogger(config.logLevel);\n  const db = await connectDatabase(config.dbUrl);\n  const app = express();\n  setupRoutes(app, db, logger);\n  return createServer(app, config.port);\n}\n\nmodule.exports = { startApp };\n"
      },
      {
        "path": "src/config.js",
        "content": "function loadConfig() {\n  return {\n    port: process.env.PORT || 3000,\n    dbUrl: process.env.DATABASE_URL || 'postgres://localhost/app',\n    logLevel: process.env.LOG_LEVEL || 'info',\n    jwtSecret: process.env.JWT_SECRET || 'dev-secret'\n  };\n}\n\nfunction validateConfig(config) {\n  const required = ['port', 'dbUrl', 'jwtSecret'];\n  for (const key of required) {\n    if (!config[key]) throw new Error(`Missing config: ${key}`);\n  }\n  return true;\n}\n\nmodule.exports = { loadConfig, validateConfig };\n"
      },
      {
        "path": "src/server.js",
        "content": "const http = require('http');\n\nfunction createServer(app, port) {\n  const server = http.createServer(app);\n  server.listen(port);\n  return server;\n}\n\nfunction gracefulShutdown(server, db) {\n  server.close(() => {\n    db.disconnect();\n    process.exit(0);\n  });\n}\n\nmodule.exports = { createServer, gracefulShutdown };\n"
      },
      {
        "path": "src/routes.js",
        "content": "const { getUsers, createUser, deleteUser } = require('./handlers/users');\nconst { getProducts, getProductById } = require('./handlers/products');\nconst { authenticate } = require('./middleware/auth');\n\nfunction setupRoutes(app, db, logger) {\n  app.use(express.json());\n  \n  app.get('/api/users', authenticate, getUsers(db));\n  app.post('/api/users', authenticate, createUser(db));\n  app.delete('/api/users/:id', authenticate, deleteUser(db));\n  \n  app.get('/api/products', getProducts(db));\n  app.get('/api/products/:id', getProductById(db));\n  \n  app.use((err, req, res, next) => {\n    logger.error(err);\n    res.status(500).json({ error: 'Internal error' });\n  });\n}\n\nmodule.exports = { setupRoutes };\n"
      },
      {
        "path": "src/handlers/users.js",
        "content": "function getUsers(db) {\n  return async (req, res) => {\n    const users = await db.query('SELECT * FROM users');\n    res.json(users);\n  };\n}\n\nfunction createUser(db) {\n  return async (req, res) => {\n    const { name, email } = req.body;\n    const user = await db.query('INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *', [name, email]);\n    res.status(201).json(user);\n  };\n}\n\nfunction deleteUser(db) {\n  return async (req, res) => {\n    await db.query('DELETE FROM users WHERE id = $1', [req.params.id]);\n    res.status(204).end();\n  };\n}\n\nmodule.exports = { getUsers, createUser, deleteUser };\n"
      },
      {
        "path": "src/handlers/products.js",
        "content": "function getProducts(db) {\n  return async (req, res) => {\n    const products = await db.query('SELECT * FROM products');\n    res.json(products);\n  };\n}\n\nfunction getProductById(db) {\n  return async (req, res) => {\n    const product = await db.query('SELECT * FROM products WHERE id = $1', [req.params.id]);\n    if (!product) return res.status(404).json({ error: 'Not found' });\n    res.json(product);\n  };\n}\n\nmodule.exports = { getProducts, getProductById };\n"
      },
      {
        "path": "src/middleware/auth.js",
        "content": "const jwt = require('jsonwebtoken');\n\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token' });\n  try {\n    req.user = jwt.verify(token, process.env.JWT_SECRET);\n    next();\n  } catch {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\nfunction requireRole(role) {\n  return (req, res, next) => {\n    if (req.user?.role !== role) return res.status(403).json({ error: 'Forbidden' });\n    next();\n  };\n}\n\nmodule.exports = { authenticate, requireRole };\n"
      },
      {
        "path": "src/db.js",
        "content": "async function connectDatabase(url) {\n  // Simulated database connection\n  return {\n    query: async (sql, params) => { /* ... */ },\n    disconnect: async () => { /* ... */ }\n  };\n}\n\nmodule.exports = { connectDatabase };\n"
      },
      {
        "path": "src/utils/logger.js",
        "content": "function initLogger(level) {\n  return {\n    info: (...args) => level !== 'silent' && console.log('[INFO]', ...args),\n    warn: (...args) => level !== 'silent' && console.warn('[WARN]', ...args),\n    error: (...args) => console.error('[ERROR]', ...args),\n    debug: (...args) => level === 'debug' && console.log('[DEBUG]', ...args)\n  };\n}\n\nmodule.exports = { initLogger };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Barrel file src/index.js exists",
      "type": "file_exists",
      "target": "src/index.js",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Barrel file re-exports handler modules (users, products)",
      "type": "file_contains",
      "target": "src/index.js",
      "pattern": "require.*handlers|require.*users|require.*products",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Barrel file re-exports core modules (config, db, server)",
      "type": "file_contains",
      "target": "src/index.js",
      "pattern": "require.*config|require.*db|require.*server",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Barrel file actually exports (module.exports or exports)",
      "type": "file_contains",
      "target": "src/index.js",
      "pattern": "module\\.exports|exports\\.",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Barrel file also re-exports middleware (auth) and utils (logger)",
      "type": "file_contains",
      "target": "src/index.js",
      "pattern": "require.*auth|require.*middleware|require.*logger|require.*utils",
      "xpBonus": 50
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Ask Claude: 'Use an explore agent to find all module.exports across every file in src/'. This will show you every exported function and object.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "A barrel file imports from each module and re-exports everything. The pattern is: const { func1, func2 } = require('./module'); then include them in module.exports = { func1, func2, ... }. You need to cover: handlers/users, handlers/products, middleware/auth, db, config, server, utils/logger.",
      "xpCost": 45
    },
    {
      "level": 3,
      "text": "Create src/index.js with:\nconst { getUsers, createUser, deleteUser } = require('./handlers/users');\nconst { getProducts, getProductById } = require('./handlers/products');\nconst { authenticate, requireRole } = require('./middleware/auth');\nconst { connectDatabase } = require('./db');\nconst { loadConfig, validateConfig } = require('./config');\nconst { createServer, gracefulShutdown } = require('./server');\nconst { initLogger } = require('./utils/logger');\n\nmodule.exports = { getUsers, createUser, deleteUser, getProducts, getProductById, authenticate, requireRole, connectDatabase, loadConfig, validateConfig, createServer, gracefulShutdown, initLogger };",
      "xpCost": 85
    }
  ],

  "solution": {
    "approach": "Use an Explore subagent to audit all exports across the 9 source files, then create src/index.js that imports and re-exports everything from each module.",
    "example": "Ask 'use an explore agent to find all exports in src/', review findings, then create the barrel file importing from all 7 module paths.",
    "alternativeApproaches": [
      "Manually read each file to find exports, then write the barrel file",
      "Ask Claude to create the barrel file directly (it will use an explore agent internally to find all exports)"
    ]
  },

  "learningPoints": [
    "Subagents are specialized workers spawned via the Task tool that run in their own context",
    "Four built-in types: Explore (search), Bash (commands), Plan (architecture), general-purpose (everything)",
    "Explore agents are read-only and fast -- ideal for auditing and understanding codebases",
    "Subagents protect the main conversation from excessive output by running in isolated context",
    "Choosing the right subagent type matters: Explore for finding things, Bash for running things, Plan for designing things"
  ],

  "nextChallenge": "11-002"
}
