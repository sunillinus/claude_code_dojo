{
  "id": "08-004",
  "module": "effective-prompting",
  "title": "Breaking Down Complex Tasks",
  "description": "Learn to decompose complex features into ordered, verifiable steps, then practice by planning a notification system AND implementing the first two steps.\n\n## Why Decomposition Matters\n\nWhen you ask Claude Code to do too much at once, three things go wrong:\n\n### 1. Error Compounding\nIf step 3 has a mistake and steps 4-8 build on it, you have to undo everything. But if you verify step 3 before starting step 4, you catch mistakes when they're cheap to fix.\n\n### 2. Context Limits\nA single massive prompt leaves less room for Claude to reason. Smaller steps mean Claude can focus deeply on each one.\n\n### 3. Review Difficulty\nA 500-line diff is nearly impossible to review. Ten 50-line diffs, each with a clear purpose, can be validated individually.\n\n## The 4 Steps of Decomposition\n\n### Step 1: Identify Components\nList everything the feature needs (don't worry about order yet).\n\nFor \"Add a notification system\":\n- Notification types/interfaces\n- Database table\n- API endpoints (create, list, mark-read)\n- Real-time delivery\n- UI components\n- User preferences\n\n### Step 2: Find Dependencies\nWhich components depend on which?\n- Types come first (everything depends on them)\n- Storage depends on types\n- API depends on types + storage\n- UI depends on types + API\n\n### Step 3: Order by Dependencies\nArrange so each step only depends on completed steps:\n1. Define types -> 2. Create storage -> 3. Build API -> 4. Create UI\n\n### Step 4: Make Each Step Verifiable\nClear success criteria you can check:\n- Step 1: \"Types exist with no syntax errors\"\n- Step 2: \"Can store and retrieve a notification\"\n- Step 3: \"API endpoints return correct responses\"\n\n## Step Sizing: The Goldilocks Rule\n\n- **Big enough** to be meaningful (not \"add a semicolon\")\n- **Small enough** to review in under 5 minutes\n- **Independent enough** to verify on its own\n- **Complete enough** that the codebase works after it\n\n## The Checkpoint Pattern\n\nAfter each step, verify before proceeding:\n```\nStep 1: Create types --> Verify: no errors\nStep 2: Create storage --> Verify: tests pass\nStep 3: Create API --> Verify: endpoints work\n```\n\nIf verification fails, fix the current step before moving on.\n\n## Your Exercise\n\nThis workspace has an existing Express API with users, auth, and a database. Your task has **two parts**:\n\n### Part 1: Plan the Decomposition\nCreate `task-breakdown.md` with a 5-8 step plan for adding a notification system. Each step needs:\n- A clear description of what to build\n- Dependencies (which prior steps it requires)\n- Verification criteria (how to confirm it works)\n\n### Part 2: Implement Steps 1 and 2\n- **Step 1**: Create notification types in `src/types/notification.js` (or similar path) defining notification structure (id, userId, type, message, read status, timestamp)\n- **Step 2**: Add a notifications table to `src/db.js` so the database can store notifications\n\nThis proves you can both plan AND execute -- the two halves of the decomposition skill.\n\nRun `/dojo check` when done.",
  "difficulty": "intermediate",
  "xpReward": 125,
  "estimatedMinutes": 12,
  "skills": ["task-decomposition", "planning", "implementation"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-08-004",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Notification API Project\n\nAn Express API that needs a notification system added.\n\n## Existing Files\n\n- `src/server.js` — Express server with existing routes\n- `src/routes/auth.js` — Authentication endpoints\n- `src/routes/users.js` — User endpoints\n- `src/middleware/auth.js` — JWT auth middleware\n- `src/db.js` — SQLite database setup\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"notification-api\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"express\": \"^4.18.0\",\n    \"better-sqlite3\": \"^9.0.0\",\n    \"jsonwebtoken\": \"^9.0.0\"\n  },\n  \"devDependencies\": {\n    \"vitest\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"dev\": \"node src/server.js\",\n    \"test\": \"vitest\"\n  }\n}\n"
      },
      {
        "path": "src/server.js",
        "content": "import express from 'express';\nimport { authRouter } from './routes/auth.js';\nimport { userRouter } from './routes/users.js';\nimport { authenticate } from './middleware/auth.js';\n\nconst app = express();\napp.use(express.json());\n\n// Public routes\napp.use('/api/auth', authRouter);\n\n// Protected routes\napp.use('/api/users', authenticate, userRouter);\n\n// TODO: Add notification routes here\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n\nexport default app;\n"
      },
      {
        "path": "src/routes/auth.js",
        "content": "import { Router } from 'express';\n\nexport const authRouter = Router();\n\nauthRouter.post('/register', async (req, res) => {\n  // Registration logic\n  res.status(201).json({ message: 'User created' });\n});\n\nauthRouter.post('/login', async (req, res) => {\n  // Login logic\n  res.json({ token: 'jwt-token-here' });\n});\n"
      },
      {
        "path": "src/routes/users.js",
        "content": "import { Router } from 'express';\n\nexport const userRouter = Router();\n\nuserRouter.get('/me', async (req, res) => {\n  res.json({ user: req.user });\n});\n\nuserRouter.put('/me', async (req, res) => {\n  // Update user profile\n  res.json({ message: 'Profile updated' });\n});\n"
      },
      {
        "path": "src/middleware/auth.js",
        "content": "import jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'dev-secret';\n\nexport function authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'Authentication required' });\n\n  try {\n    req.user = jwt.verify(token, JWT_SECRET);\n    next();\n  } catch {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n"
      },
      {
        "path": "src/db.js",
        "content": "import Database from 'better-sqlite3';\n\nconst db = new Database('app.db');\n\n// Existing tables\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS users (\n    id TEXT PRIMARY KEY,\n    email TEXT UNIQUE NOT NULL,\n    password_hash TEXT NOT NULL,\n    name TEXT NOT NULL,\n    created_at TEXT DEFAULT (datetime('now'))\n  )\n`);\n\nexport default db;\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Decomposition plan exists (task-breakdown.md)",
      "type": "file_exists",
      "target": "task-breakdown.md",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Plan has at least 5 steps",
      "type": "file_contains",
      "target": "task-breakdown.md",
      "pattern": "[Ss]tep.*[5678]|##.*[5678]|\\b[5678]\\.",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Plan includes dependency information",
      "type": "file_contains",
      "target": "task-breakdown.md",
      "pattern": "[Dd]epend|[Rr]equire|[Pp]rerequisite|[Aa]fter.*[Ss]tep|[Nn]one",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Step 1 implemented: notification types file exists",
      "type": "file_exists",
      "target": "src/types/notification.js",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Step 2 implemented: notification table added to database",
      "type": "file_contains",
      "target": "src/db.js",
      "pattern": "notification",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Plan includes verification criteria for each step",
      "type": "file_contains",
      "target": "task-breakdown.md",
      "pattern": "[Vv]erif|[Cc]heck|[Cc]onfirm|[Tt]est|[Ss]uccess.*criter",
      "xpBonus": 25
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Think about what a notification system needs: types/models first (everything depends on them), then storage (database table), then API endpoints, then features like mark-as-read. For each step, note what it depends on and how you'd verify it works.",
      "xpCost": 10
    },
    {
      "level": 2,
      "text": "For the plan: (1) Define notification types, (2) Create database table, (3) Build CRUD API endpoints, (4) Add mark-as-read, (5) Add notification preferences. For implementation: create src/types/notification.js with a Notification class or object shape (id, userId, type, message, read, createdAt). Then add a CREATE TABLE IF NOT EXISTS notifications statement to src/db.js.",
      "xpCost": 25
    },
    {
      "level": 3,
      "text": "Ask Claude: '1) Create task-breakdown.md with 5-8 steps for adding a notification system to this Express API. Each step needs: description, dependencies, and verification criteria. 2) Then implement Step 1: create src/types/notification.js defining notification types (id, userId, type, message, read, createdAt). 3) Then implement Step 2: add a notifications table to src/db.js with columns matching the types.'",
      "xpCost": 50
    }
  ],

  "solution": {
    "approach": "Create a decomposition plan in task-breakdown.md with 5-8 steps including dependencies and verification criteria. Then implement Steps 1 (notification types) and 2 (database table).",
    "example": "Plan: Step 1 types (no deps), Step 2 database (deps: 1), Step 3 API (deps: 1-2), Step 4 mark-read (deps: 3), Step 5 preferences (deps: 1-2). Implement: create notification types file and add notifications table to db.js.",
    "alternativeApproaches": [
      "Create the plan first, get feedback, then implement the first 2 steps",
      "Implement steps 1-2 first to understand the system, then write the plan"
    ]
  },

  "learningPoints": [
    "Decomposition prevents error compounding: verify each step before building on it",
    "Dependencies determine order: types before storage, storage before API",
    "Each step should be independently verifiable with clear success criteria",
    "The plan-then-execute pattern catches mistakes early when they're cheap to fix",
    "Step sizing matters: big enough to be meaningful, small enough to review in 5 minutes"
  ],

  "nextChallenge": "08-005"
}
