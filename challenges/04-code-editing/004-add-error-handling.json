{
  "id": "04-004",
  "module": "code-editing",
  "title": "Add Error Handling",
  "description": "Learn to add comprehensive error handling to code that has none. Robust error handling prevents crashes, helps debugging, and creates better user experiences through graceful failure.",
  "difficulty": "intermediate",
  "xpReward": 250,
  "estimatedMinutes": 15,
  "skills": ["error-handling", "defensive-coding", "input-validation", "custom-errors", "async-error-patterns"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-04-004",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Add Error Handling\n\nLearn to add comprehensive error handling to fragile code.\n\n## Why Error Handling Matters\n\nCode without error handling works great... until something goes wrong.\nThen it crashes with cryptic messages, corrupts data, or silently\nproduces wrong results. The difference between amateur and professional\ncode is often just error handling.\n\n## Error Handling Patterns\n\n### 1. try/catch for Synchronous Errors\n\nThe basic pattern wraps code that might fail:\n\n```javascript\ntry {\n  const result = JSON.parse(userInput);\n  processData(result);\n} catch (error) {\n  console.error('Failed to parse input:', error.message);\n  return { success: false, error: 'Invalid JSON input' };\n}\n```\n\n### 2. try/catch with async/await\n\nAsync operations need the same protection:\n\n```javascript\nasync function fetchUser(id) {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    if (!response.ok) {\n      throw new Error(`API error: ${response.status} ${response.statusText}`);\n    }\n    return await response.json();\n  } catch (error) {\n    throw new Error(`Failed to fetch user ${id}: ${error.message}`);\n  }\n}\n```\n\nKey point: always check `response.ok` before calling `.json()` -\na 404 or 500 response is NOT a network error, so it won't trigger\ncatch on its own.\n\n### 3. Custom Error Classes\n\nCustom errors let you distinguish between error types:\n\n```javascript\nclass ValidationError extends Error {\n  constructor(field, message) {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NotFoundError extends Error {\n  constructor(resource, id) {\n    super(`${resource} with id ${id} not found`);\n    this.name = 'NotFoundError';\n    this.resource = resource;\n    this.id = id;\n  }\n}\n```\n\nCallers can then handle different errors differently:\n```javascript\ntry {\n  await updateUser(id, data);\n} catch (error) {\n  if (error instanceof ValidationError) {\n    showFieldError(error.field, error.message);\n  } else if (error instanceof NotFoundError) {\n    showNotFound(error.resource);\n  } else {\n    showGenericError();\n  }\n}\n```\n\n### 4. Input Validation: Fail Fast\n\nValidate inputs at function boundaries - don't let bad data travel\ndeep into your code:\n\n```javascript\nfunction calculateDiscount(price, percentage) {\n  if (typeof price !== 'number' || price < 0) {\n    throw new ValidationError('price', 'Price must be a non-negative number');\n  }\n  if (typeof percentage !== 'number' || percentage < 0 || percentage > 100) {\n    throw new ValidationError('percentage', 'Percentage must be between 0 and 100');\n  }\n  return price * (percentage / 100);\n}\n```\n\n### 5. Graceful Degradation vs. Fail-Fast\n\n**Fail-Fast**: Stop immediately when something is wrong.\nBest for: data integrity, development, internal APIs.\n\n```javascript\n// Fail-fast: crash rather than use bad data\nfunction processPayment(order) {\n  if (!order.total) throw new Error('Order total is required');\n  // ...\n}\n```\n\n**Graceful Degradation**: Continue with reduced functionality.\nBest for: user-facing features, non-critical operations.\n\n```javascript\n// Graceful: show what we can, skip what fails\nfunction renderDashboard(data) {\n  const widgets = [];\n  try { widgets.push(renderChart(data.chart)); } catch { widgets.push(renderFallback('Chart unavailable')); }\n  try { widgets.push(renderTable(data.table)); } catch { widgets.push(renderFallback('Table unavailable')); }\n  return widgets;\n}\n```\n\n### 6. Error Propagation\n\nNot every function should catch errors. Sometimes the right thing is\nto let them bubble up to a caller that knows how to handle them:\n\n```javascript\n// DON'T catch just to re-throw the same error\nasync function getUser(id) {\n  try {\n    return await db.query('SELECT * FROM users WHERE id = ?', [id]);\n  } catch (error) {\n    throw error;  // Pointless! Just don't catch it.\n  }\n}\n\n// DO catch to add context or convert to a different error type\nasync function getUser(id) {\n  try {\n    return await db.query('SELECT * FROM users WHERE id = ?', [id]);\n  } catch (error) {\n    throw new DatabaseError(`Failed to fetch user ${id}`, { cause: error });\n  }\n}\n```\n\n## The Workspace\n\nYou have `inventoryService.js` - an inventory management service with\nZERO error handling. Problems include:\n- No input validation (null product names, negative quantities)\n- Async operations without try/catch\n- Direct property access on potentially null objects\n- No response status checking on fetch calls\n- Division without zero-checking\n- JSON parsing that could fail silently\n\nYou also have `errors.js` which is empty - you'll create custom\nerror classes here.\n\n## Objectives\n\n1. Add input validation to all functions (fail fast on bad input)\n2. Add try/catch blocks to all async functions\n3. Check response.ok before parsing JSON from fetch calls\n4. Create custom error classes in errors.js (ValidationError,\n   NotFoundError, ServiceError)\n5. Use the custom error classes in inventoryService.js\n6. Handle the division-by-zero case in calculateAveragePrice\n7. Add null checks before accessing properties on objects\n"
      },
      {
        "path": "inventoryService.js",
        "content": "// Inventory service - NO error handling!\n// Every function here is fragile and will crash on bad input.\n\nconst API_URL = 'https://api.warehouse.com';\n\n/**\n * Fetch a product from the warehouse API.\n * @param {string} productId - The product ID.\n * @returns {Promise<Object>} The product data.\n */\nasync function getProduct(productId) {\n  const response = await fetch(`${API_URL}/products/${productId}`);\n  const data = await response.json();\n  return data;\n}\n\n/**\n * Update the stock quantity for a product.\n * @param {string} productId - The product ID.\n * @param {number} quantity - The new quantity.\n * @returns {Promise<Object>} The updated product.\n */\nasync function updateStock(productId, quantity) {\n  const response = await fetch(`${API_URL}/products/${productId}/stock`, {\n    method: 'PUT',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ quantity })\n  });\n  const result = await response.json();\n  return result;\n}\n\n/**\n * Transfer stock between two warehouses.\n * @param {string} fromWarehouse - Source warehouse ID.\n * @param {string} toWarehouse - Destination warehouse ID.\n * @param {string} productId - The product to transfer.\n * @param {number} quantity - Amount to transfer.\n * @returns {Promise<Object>} Transfer confirmation.\n */\nasync function transferStock(fromWarehouse, toWarehouse, productId, quantity) {\n  const sourceProduct = await getProduct(productId);\n  const newSourceQty = sourceProduct.stock - quantity;\n\n  await updateStock(productId, newSourceQty);\n\n  const response = await fetch(`${API_URL}/transfers`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      from: fromWarehouse,\n      to: toWarehouse,\n      productId,\n      quantity\n    })\n  });\n  const confirmation = await response.json();\n  return confirmation;\n}\n\n/**\n * Calculate the average price across a list of products.\n * @param {Array} products - Array of product objects.\n * @returns {number} The average price.\n */\nfunction calculateAveragePrice(products) {\n  const total = products.reduce((sum, p) => sum + p.price, 0);\n  return total / products.length;\n}\n\n/**\n * Generate an inventory report.\n * @param {string} warehouseId - The warehouse ID.\n * @returns {Promise<Object>} The inventory report.\n */\nasync function generateReport(warehouseId) {\n  const response = await fetch(`${API_URL}/warehouses/${warehouseId}/inventory`);\n  const inventory = await response.json();\n\n  const totalValue = inventory.items.reduce(\n    (sum, item) => sum + (item.price * item.quantity), 0\n  );\n  const avgPrice = calculateAveragePrice(inventory.items);\n\n  const lowStock = inventory.items.filter(item => item.quantity < item.reorderPoint);\n\n  return {\n    warehouseId,\n    totalItems: inventory.items.length,\n    totalValue: totalValue.toFixed(2),\n    averagePrice: avgPrice.toFixed(2),\n    lowStockItems: lowStock.map(item => ({\n      name: item.name,\n      current: item.quantity,\n      reorderAt: item.reorderPoint\n    }))\n  };\n}\n\n/**\n * Bulk import products from a JSON string.\n * @param {string} jsonData - JSON string of products to import.\n * @returns {Promise<Object>} Import results.\n */\nasync function bulkImport(jsonData) {\n  const products = JSON.parse(jsonData);\n\n  const results = [];\n  for (const product of products) {\n    const response = await fetch(`${API_URL}/products`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(product)\n    });\n    const created = await response.json();\n    results.push(created);\n  }\n\n  return { imported: results.length, products: results };\n}\n\nmodule.exports = {\n  getProduct,\n  updateStock,\n  transferStock,\n  calculateAveragePrice,\n  generateReport,\n  bulkImport\n};\n"
      },
      {
        "path": "errors.js",
        "content": "// Custom error classes - to be implemented\n// Create: ValidationError, NotFoundError, ServiceError\n\nmodule.exports = {};\n"
      },
      {
        "path": "app.js",
        "content": "const {\n  getProduct,\n  updateStock,\n  transferStock,\n  generateReport,\n  bulkImport\n} = require('./inventoryService');\n\n// These calls will all crash without error handling:\nasync function main() {\n  // Fetching a product - what if the API is down?\n  const product = await getProduct('PROD-001');\n  console.log(product.name);\n\n  // Updating stock - what if quantity is negative?\n  await updateStock('PROD-001', 50);\n\n  // Transfer - what if source doesn't have enough stock?\n  await transferStock('WH-EAST', 'WH-WEST', 'PROD-001', 10);\n\n  // Report - what if warehouse doesn't exist?\n  const report = await generateReport('WH-EAST');\n  console.log(report);\n\n  // Bulk import - what if the JSON is invalid?\n  await bulkImport('not valid json');\n}\n\nmain();\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "inventoryService.js has try/catch blocks for async operations",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "try\\s*\\{[\\s\\S]*?await[\\s\\S]*?\\}\\s*catch",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "inventoryService.js checks response.ok or response.status before parsing",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "response\\.ok|!response\\.ok|response\\.status",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "inventoryService.js validates input parameters (checks for null/undefined/type)",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "!productId|typeof.*!==|!warehouseId|!quantity|!fromWarehouse|!toWarehouse",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "calculateAveragePrice handles empty array or division by zero",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "calculateAveragePrice[\\s\\S]{0,300}(length\\s*===\\s*0|!products|products\\.length\\s*<|!Array)",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "errors.js defines a ValidationError class",
      "type": "file_contains",
      "target": "errors.js",
      "pattern": "class ValidationError extends Error",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "errors.js defines a NotFoundError class",
      "type": "file_contains",
      "target": "errors.js",
      "pattern": "class NotFoundError extends Error",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "errors.js defines a ServiceError class",
      "type": "file_contains",
      "target": "errors.js",
      "pattern": "class ServiceError extends Error",
      "required": true
    },
    {
      "id": "obj-8",
      "description": "inventoryService.js imports and uses custom error classes",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "require\\(.*errors|from.*errors",
      "required": true
    },
    {
      "id": "obj-9",
      "description": "inventoryService.js throws or creates instances of custom errors",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "new ValidationError|new NotFoundError|new ServiceError",
      "required": true
    },
    {
      "id": "obj-10",
      "description": "bulkImport handles JSON.parse failure with try/catch",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "bulkImport[\\s\\S]{0,300}try[\\s\\S]{0,200}JSON\\.parse|JSON\\.parse[\\s\\S]{0,200}catch",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Custom error classes export their name property in the constructor",
      "type": "file_contains",
      "target": "errors.js",
      "pattern": "this\\.name\\s*=",
      "xpBonus": 25
    },
    {
      "id": "bonus-2",
      "description": "transferStock validates that quantity doesn't exceed source stock",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "transferStock[\\s\\S]{0,800}(quantity\\s*>|stock\\s*<|insufficient|enough|exceed|negative)",
      "xpBonus": 35
    },
    {
      "id": "bonus-3",
      "description": "Error messages include context (what operation failed and why)",
      "type": "file_contains",
      "target": "inventoryService.js",
      "pattern": "Failed to|Unable to|Could not|Invalid.*for|cannot be",
      "xpBonus": 25
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Start by identifying every vulnerability: async calls without try/catch, fetch without response.ok check, JSON.parse without try/catch, division by products.length (could be 0), property access on potentially null objects (sourceProduct.stock), and no input validation. Then create custom error classes in errors.js first, since inventoryService.js will need to import them.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "Ask Claude Code in two steps: First, 'Create three custom error classes in errors.js: ValidationError (with field and message), NotFoundError (with resource and id), ServiceError (with operation and original error). All should extend Error and set this.name.' Then: 'Add comprehensive error handling to inventoryService.js: import errors from errors.js, add input validation at the top of each function, wrap async operations in try/catch, check response.ok, handle division by zero in calculateAveragePrice, wrap JSON.parse in try/catch for bulkImport.'",
      "xpCost": 45
    },
    {
      "level": 3,
      "text": "Specific fixes needed: 1) getProduct - validate productId, try/catch the fetch, check response.ok, throw NotFoundError for 404. 2) updateStock - validate productId and quantity (must be non-negative number), try/catch, check response.ok. 3) transferStock - validate all 4 params, check sourceProduct.stock >= quantity, try/catch the whole operation. 4) calculateAveragePrice - check Array.isArray, check length > 0, return 0 for empty. 5) generateReport - validate warehouseId, try/catch, check response.ok, null-check inventory.items. 6) bulkImport - try/catch around JSON.parse, validate it's an array.",
      "xpCost": 85
    }
  ],

  "solution": {
    "approach": "First create custom error classes in errors.js, then systematically add error handling to every function in inventoryService.js: input validation, try/catch for async operations, response status checks, and appropriate error types.",
    "example": "Create ValidationError, NotFoundError, and ServiceError in errors.js. Then add error handling to inventoryService.js: validate inputs, wrap async calls in try/catch, check response.ok, handle division by zero, and use the custom error classes.",
    "alternativeApproaches": [
      "Work through one function at a time, adding all error handling to each before moving on",
      "Add input validation to all functions first, then add try/catch blocks, then add custom errors",
      "Ask Claude Code to identify all vulnerabilities first, then fix them systematically"
    ]
  },

  "learningPoints": [
    "Always check response.ok before calling response.json() - HTTP errors (404, 500) don't trigger catch",
    "Custom error classes (extending Error) let callers distinguish between error types",
    "Input validation should happen at function boundaries - fail fast before doing work",
    "JSON.parse is a common crash point and always needs try/catch protection",
    "Division by zero returns Infinity in JavaScript (not an error) but usually indicates a bug",
    "The choice between fail-fast (throw) and graceful degradation (return default) depends on the context",
    "Error messages should include context: what operation was attempted and what went wrong"
  ],

  "nextChallenge": "04-005"
}