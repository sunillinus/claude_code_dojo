{
  "id": "06-005",
  "module": "testing-tdd",
  "title": "Test Coverage Analysis",
  "description": "Learn to measure test coverage, understand what coverage metrics mean (and don't mean), and improve coverage by targeting uncovered branches and error paths.",
  "difficulty": "advanced",
  "xpReward": 300,
  "estimatedMinutes": 20,
  "skills": [
    "coverage",
    "branch-coverage",
    "test-analysis",
    "coverage-improvement"
  ],
  "setup": {
    "workingDir": "~/dojo-workspace/challenge-06-005",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Test Coverage Analysis\n\nLearn to measure, interpret, and improve test coverage. Understand\nwhat coverage tells you and -- critically -- what it does NOT.\n\n## What is Test Coverage?\n\nTest coverage measures how much of your source code is executed when\nyour tests run. It answers: \"Which lines, branches, and functions\ndid my tests actually exercise?\"\n\n## Types of Coverage\n\n### Line Coverage\nPercentage of source code lines that were executed during tests.\n```\nLine 1: const x = 5;       // COVERED (executed)\nLine 2: if (x > 10) {      // COVERED (evaluated)\nLine 3:   return 'big';    // NOT COVERED (branch not taken)\nLine 4: }                  //\nLine 5: return 'small';    // COVERED (executed)\n```\nLine coverage here: 3 of 4 executable lines = 75%\n\n### Branch Coverage\nPercentage of decision branches (if/else, switch, ternary) where\nBOTH paths have been tested.\n```\nif (x > 10) {      // Branch: true path AND false path\n  return 'big';    // Only tested if x > 10 (true branch)\n} else {\n  return 'small';  // Only tested if x <= 10 (false branch)\n}\n```\nIf you only test with x = 5, you cover the false branch but NOT\nthe true branch. Branch coverage = 50%.\n\n### Function Coverage\nPercentage of functions that were called at least once.\n\n### Statement Coverage\nSimilar to line coverage but counts individual statements\n(multiple statements can be on one line).\n\n## Branch Coverage > Line Coverage\n\nBranch coverage is MORE VALUABLE than line coverage because it\nensures you have tested both sides of every decision. Consider:\n\n```javascript\nfunction divide(a, b) {\n  if (b === 0) throw new Error('Division by zero');\n  return a / b;\n}\n```\n\nTesting only `divide(10, 2)` gives:\n- Line coverage: 66% (line 1 and 2 of 3 executed)\n- Branch coverage: 50% (only the `b !== 0` branch)\n\nThe error-handling path is completely untested! Branch coverage\nexposes this gap more clearly.\n\n## Running Coverage with Node.js\n\nNode.js has built-in test coverage (experimental):\n```bash\nnode --test --experimental-test-coverage\n```\n\nOr with npm scripts:\n```bash\nnpm run test:coverage\n```\n\nThe output shows a table like:\n```\n# coverage\n| File        | Line % | Branch % | Funcs % |\n| validator.js | 65.22  | 42.86    | 80.00   |\n```\n\n## Reading Coverage Reports\n\nWhen you see low coverage, ask:\n1. **Which functions are untested?** (Funcs % < 100)\n2. **Which branches are missed?** (Branch % < Line %)\n3. **Are error paths tested?** (Usually the first gap)\n4. **Are edge cases covered?** (Empty arrays, null, zero)\n\n## What 100% Coverage DOES Mean\n\n- Every line of code was executed at least once during tests\n- Every branch (if/else) was taken at least once\n- Every function was called at least once\n\n## What 100% Coverage DOES NOT Mean\n\n- Every edge case is handled\n- The code is bug-free\n- The assertions are meaningful (you could execute code without asserting)\n- The code handles all input combinations\n- Performance is acceptable\n\nExample of 100% coverage with a terrible test:\n```javascript\ntest('covers the function', () => {\n  divide(10, 2); // 100% coverage, ZERO assertions!\n  divide(10, 0); // throws but we don't check!\n});\n```\nThis executes every line but verifies nothing.\n\n## What to Prioritize for Coverage\n\nNot all code deserves the same coverage effort:\n\n| Priority | What | Why |\n|----------|------|-----|\n| HIGH | Business logic | Bugs here lose money/users |\n| HIGH | Error handling | Untested errors crash in production |\n| HIGH | Security code | Auth/validation bugs are critical |\n| MEDIUM | Data transformation | Important but often straightforward |\n| LOW | Simple getters/setters | Trivial, hard to get wrong |\n| LOW | Generated code | Don't test the generator's output |\n| LOW | Type-only code | TypeScript types, interfaces |\n\n## When NOT to Chase 100%\n\n- Simple pass-through functions\n- Configuration objects\n- Framework boilerplate\n- Generated code\n- Code that will be replaced soon\n\nAiming for 80-90% coverage on critical code is usually the sweet\nspot. The last 10% often costs more effort than it provides value.\n\n## Your Task\n\nThe file `validator.js` is a comprehensive input validation module.\nIt has existing tests in `validator.test.js` that cover only the\nhappy paths (~50% coverage). The existing tests pass, but many\nbranches and error conditions are untested.\n\nYour job:\n1. Run `npm run test:coverage` to see the current coverage\n2. Analyze which lines and branches are NOT covered\n3. Add new tests to `validator.test.js` to improve coverage\n4. Target the uncovered BRANCHES specifically (error handling,\n   edge cases, validation failures)\n5. Aim for >85% branch coverage\n\nDo NOT modify `validator.js` -- only add tests.\n\n## Objectives\n1. Run coverage analysis and understand the gaps\n2. Add tests for uncovered error-handling branches\n3. Add tests for uncovered validation logic\n4. Improve overall test coverage to >85%\n5. All tests pass\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"coverage-challenge\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"test\": \"node --test\",\n    \"test:coverage\": \"node --test --experimental-test-coverage\"\n  }\n}\n"
      },
      {
        "path": "validator.js",
        "content": "/**\n * Input Validation Module\n * Provides comprehensive validation for user input, forms, and data.\n */\n\n/**\n * Validates an email address.\n * @param {string} email\n * @returns {{ valid: boolean, error?: string }}\n */\nfunction validateEmail(email) {\n  if (typeof email !== 'string') {\n    return { valid: false, error: 'Email must be a string' };\n  }\n\n  const trimmed = email.trim();\n\n  if (trimmed.length === 0) {\n    return { valid: false, error: 'Email is required' };\n  }\n\n  if (trimmed.length > 254) {\n    return { valid: false, error: 'Email is too long' };\n  }\n\n  const parts = trimmed.split('@');\n  if (parts.length !== 2) {\n    return { valid: false, error: 'Email must contain exactly one @ symbol' };\n  }\n\n  const [local, domain] = parts;\n\n  if (local.length === 0) {\n    return { valid: false, error: 'Email local part is empty' };\n  }\n\n  if (domain.length === 0) {\n    return { valid: false, error: 'Email domain is empty' };\n  }\n\n  if (!domain.includes('.')) {\n    return { valid: false, error: 'Email domain must contain a dot' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Validates a password against security requirements.\n * @param {string} password\n * @returns {{ valid: boolean, errors: string[] }}\n */\nfunction validatePassword(password) {\n  const errors = [];\n\n  if (typeof password !== 'string') {\n    return { valid: false, errors: ['Password must be a string'] };\n  }\n\n  if (password.length < 8) {\n    errors.push('Password must be at least 8 characters');\n  }\n\n  if (password.length > 128) {\n    errors.push('Password must not exceed 128 characters');\n  }\n\n  if (!/[A-Z]/.test(password)) {\n    errors.push('Password must contain an uppercase letter');\n  }\n\n  if (!/[a-z]/.test(password)) {\n    errors.push('Password must contain a lowercase letter');\n  }\n\n  if (!/[0-9]/.test(password)) {\n    errors.push('Password must contain a digit');\n  }\n\n  if (!/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>?]/.test(password)) {\n    errors.push('Password must contain a special character');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Validates a username.\n * @param {string} username\n * @returns {{ valid: boolean, error?: string }}\n */\nfunction validateUsername(username) {\n  if (typeof username !== 'string') {\n    return { valid: false, error: 'Username must be a string' };\n  }\n\n  const trimmed = username.trim();\n\n  if (trimmed.length < 3) {\n    return { valid: false, error: 'Username must be at least 3 characters' };\n  }\n\n  if (trimmed.length > 30) {\n    return { valid: false, error: 'Username must not exceed 30 characters' };\n  }\n\n  if (!/^[a-zA-Z]/.test(trimmed)) {\n    return { valid: false, error: 'Username must start with a letter' };\n  }\n\n  if (!/^[a-zA-Z0-9_]+$/.test(trimmed)) {\n    return { valid: false, error: 'Username can only contain letters, numbers, and underscores' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Validates an age value.\n * @param {*} age\n * @returns {{ valid: boolean, error?: string }}\n */\nfunction validateAge(age) {\n  if (typeof age !== 'number') {\n    return { valid: false, error: 'Age must be a number' };\n  }\n\n  if (!Number.isInteger(age)) {\n    return { valid: false, error: 'Age must be a whole number' };\n  }\n\n  if (age < 0) {\n    return { valid: false, error: 'Age cannot be negative' };\n  }\n\n  if (age > 150) {\n    return { valid: false, error: 'Age cannot exceed 150' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Validates a complete user registration form.\n * @param {Object} form - The form data\n * @returns {{ valid: boolean, errors: Object }}\n */\nfunction validateRegistrationForm(form) {\n  if (!form || typeof form !== 'object') {\n    return { valid: false, errors: { form: 'Form data is required' } };\n  }\n\n  const errors = {};\n\n  const emailResult = validateEmail(form.email);\n  if (!emailResult.valid) {\n    errors.email = emailResult.error;\n  }\n\n  const passwordResult = validatePassword(form.password);\n  if (!passwordResult.valid) {\n    errors.password = passwordResult.errors;\n  }\n\n  const usernameResult = validateUsername(form.username);\n  if (!usernameResult.valid) {\n    errors.username = usernameResult.error;\n  }\n\n  if (form.age !== undefined) {\n    const ageResult = validateAge(form.age);\n    if (!ageResult.valid) {\n      errors.age = ageResult.error;\n    }\n  }\n\n  return {\n    valid: Object.keys(errors).length === 0,\n    errors\n  };\n}\n\nmodule.exports = {\n  validateEmail,\n  validatePassword,\n  validateUsername,\n  validateAge,\n  validateRegistrationForm\n};\n"
      },
      {
        "path": "validator.test.js",
        "content": "const { test, describe } = require('node:test');\nconst assert = require('node:assert');\nconst {\n  validateEmail,\n  validatePassword,\n  validateUsername,\n  validateAge,\n  validateRegistrationForm\n} = require('./validator');\n\n// ===========================================\n// EXISTING TESTS - these cover only happy paths\n// Your job: add more tests below to improve coverage\n// ===========================================\n\ndescribe('validateEmail', () => {\n  test('accepts a valid email', () => {\n    const result = validateEmail('user@example.com');\n    assert.strictEqual(result.valid, true);\n  });\n});\n\ndescribe('validatePassword', () => {\n  test('accepts a strong password', () => {\n    const result = validatePassword('MyP@ssw0rd!');\n    assert.strictEqual(result.valid, true);\n    assert.deepStrictEqual(result.errors, []);\n  });\n});\n\ndescribe('validateUsername', () => {\n  test('accepts a valid username', () => {\n    const result = validateUsername('john_doe');\n    assert.strictEqual(result.valid, true);\n  });\n});\n\ndescribe('validateAge', () => {\n  test('accepts a valid age', () => {\n    const result = validateAge(25);\n    assert.strictEqual(result.valid, true);\n  });\n});\n\ndescribe('validateRegistrationForm', () => {\n  test('accepts a complete valid form', () => {\n    const result = validateRegistrationForm({\n      email: 'user@example.com',\n      password: 'MyP@ssw0rd!',\n      username: 'john_doe',\n      age: 25\n    });\n    assert.strictEqual(result.valid, true);\n    assert.deepStrictEqual(result.errors, {});\n  });\n});\n\n// ===========================================\n// ADD YOUR TESTS BELOW\n// Run: npm run test:coverage to see what's missing\n// Target the uncovered branches and error paths\n// ===========================================\n"
      }
    ],
    "cleanBefore": true
  },
  "objectives": [
    {
      "id": "obj-1",
      "description": "Add tests for email validation error cases",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "email.*invalid|invalid.*email|empty.*email|Email.*required|Email.*string|Email.*@|Email.*domain|Email.*dot|Email.*long",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Add tests for password validation failures",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "password.*short|password.*8|uppercase|lowercase|digit|special.*character|Password.*string",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Add tests for username validation failures",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "username.*short|username.*3|username.*30|start.*letter|Username.*string|letters.*numbers.*underscore",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Add tests for age validation failures",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "age.*number|age.*negative|age.*150|age.*whole|age.*integer|Age.*string",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Add tests for registration form validation failures",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "form.*invalid|invalid.*form|null.*form|form.*required|missing|registration.*error",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "All tests pass",
      "type": "command_output_contains",
      "command": "cd ~/dojo-workspace/challenge-06-005 && npm test 2>&1",
      "pattern": "pass|ok",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "Coverage report can be generated",
      "type": "command_output_contains",
      "command": "cd ~/dojo-workspace/challenge-06-005 && npm run test:coverage 2>&1",
      "pattern": "coverage|%",
      "required": true
    }
  ],
  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Test email with no @ symbol",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "no.*@|without.*@|missing.*@|no-at|noemail",
      "xpBonus": 25
    },
    {
      "id": "bonus-2",
      "description": "Test password with multiple validation failures at once",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "multiple.*error|several.*error|errors\\.length|all.*fail",
      "xpBonus": 30
    },
    {
      "id": "bonus-3",
      "description": "Test registration form with missing optional age field",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "without.*age|no.*age|age.*undefined|optional.*age|age.*optional",
      "xpBonus": 30
    },
    {
      "id": "bonus-4",
      "description": "Test email that is too long (>254 characters)",
      "type": "file_contains",
      "target": "validator.test.js",
      "pattern": "too long|254|long.*email|email.*long|exceed.*length",
      "xpBonus": 25
    }
  ],
  "hints": [
    {
      "level": 1,
      "text": "Start by running `npm run test:coverage` to see which lines and branches are currently covered. You will see that only the happy paths are tested. For each validation function, look at all the `if` statements that return early with errors -- these are the uncovered branches. Write a test for each one. For example, validateEmail has checks for: non-string input, empty string, too long, wrong number of @ symbols, empty local part, empty domain, domain without a dot.",
      "xpCost": 20
    },
    {
      "level": 2,
      "text": "For each function, add tests for every error branch: validateEmail - test non-string, empty, too long (>254), no @, multiple @, empty local, empty domain, domain without dot. validatePassword - test non-string, too short (<8), too long (>128), missing uppercase, missing lowercase, missing digit, missing special char. validateUsername - test non-string, too short (<3), too long (>30), starts with number, contains invalid chars. validateAge - test non-number, decimal, negative, over 150. validateRegistrationForm - test null/undefined, empty object, all fields invalid, missing optional age.",
      "xpCost": 60
    },
    {
      "level": 3,
      "text": "Ask Claude: 'The file validator.test.js has only happy-path tests. I need to add tests for all error branches to improve coverage above 85%. Read validator.js and add tests to validator.test.js (below the existing tests) for: 1) validateEmail: non-string, empty, too long (>254 chars), no @ symbol, multiple @, empty local part, empty domain, domain without dot. 2) validatePassword: non-string, too short, too long (>128), missing uppercase, missing lowercase, missing digit, missing special char, multiple failures at once. 3) validateUsername: non-string, too short (<3), too long (>30), starts with number, contains spaces/special chars. 4) validateAge: non-number, decimal, negative, over 150. 5) validateRegistrationForm: null input, all fields invalid, without optional age. Keep existing tests, only add new ones.'",
      "xpCost": 120
    }
  ],
  "solution": {
    "approach": "Run coverage to identify gaps. For each validation function, identify all the if/else branches that are not covered by the existing happy-path tests. Add tests for each error condition: type checks, boundary values, missing fields, invalid formats. Focus on branches first since branch coverage is more valuable than line coverage.",
    "example": "Analyze coverage report, identify untested error branches, add tests for each validation failure path",
    "alternativeApproaches": [
      "Use the coverage report line numbers to precisely target uncovered lines",
      "Start with the function that has lowest branch coverage",
      "Add integration-level tests through validateRegistrationForm to cover multiple validators at once"
    ]
  },
  "learningPoints": [
    "Coverage measures which lines/branches/functions were executed during tests",
    "Branch coverage is more valuable than line coverage -- it ensures both paths of every if/else are tested",
    "100% coverage does NOT mean bug-free code -- it only means every line was executed",
    "Coverage without meaningful assertions is useless (executing code != verifying behavior)",
    "Prioritize coverage for business logic, error handling, and security code",
    "The sweet spot is usually 80-90% coverage on critical code",
    "Node.js built-in coverage: `node --test --experimental-test-coverage`",
    "Look at the gap between line coverage and branch coverage to find untested error paths"
  ],
  "nextChallenge": "07-001"
}
