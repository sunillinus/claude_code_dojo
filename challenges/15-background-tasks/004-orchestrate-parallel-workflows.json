{
  "id": "15-004",
  "module": "background-tasks",
  "title": "Orchestrate Parallel Workflows",
  "description": "Learn to design complex workflows with fan-out, fan-in, and dependency chains, then practice by documenting 3 modules in parallel and creating a combined API reference.\n\n## Why Orchestration Matters\n\nReal-world tasks rarely consist of a single step. You often need to process multiple modules, run multiple checks, and combine results. The order matters: some tasks can run simultaneously, others must wait for prerequisites.\n\nOrchestration is the skill of **planning which tasks run in parallel and which must be sequential**, then executing that plan efficiently.\n\n## Core Pattern 1: Fan-Out\n\nFan-out means launching multiple independent tasks from a single point. Each runs in parallel.\n\n```\n                    +--> [Process module A]\n                    |\n[Start] -- fan-out --+--> [Process module B]\n                    |\n                    +--> [Process module C]\n```\n\nIn Claude Code, fan-out looks like:\n- Multiple parallel tool calls (e.g., 3 Edit calls in one message)\n- Multiple background Bash commands launched together\n- Multiple subagents launched with `run_in_background: true`\n\n## Core Pattern 2: Fan-In\n\nFan-in means waiting for all parallel tasks to complete, then combining their results.\n\n```\n[Process module A]  --+\n                      |\n[Process module B]  --+--> fan-in --> [Create combined output]\n                      |\n[Process module C]  --+\n```\n\nFan-in requires:\n- Waiting for all parallel tasks to finish\n- Reading/collecting all results\n- Synthesizing into a single output\n\n## Core Pattern 3: Dependency Chains\n\nSome tasks have strict ordering. Task B cannot start until Task A completes.\n\n```\n[Install deps] --> [Run build] --> [Run tests on build output]\n```\n\nCannot parallelize across a dependency.\n\n## Mixed Workflows: The Real Pattern\n\nMost real workflows combine all three:\n\n```\n                         +--> [Lint]   --+\n[Install deps] -- then --+               +--> then --> [Deploy]\n                         +--> [Test]  --+\n                         |\n                         +--> [Build] --+\n```\n\nBreaking it down:\n1. **Sequential**: Install deps must complete first (dependency)\n2. **Fan-out**: Lint, Test, Build run in parallel (independent)\n3. **Fan-in**: Wait for all three to complete\n4. **Sequential**: Deploy only after all three succeed\n\n## Designing a Workflow\n\n1. **List all tasks** — everything that needs to happen\n2. **Map dependencies** — for each task: what must complete first?\n3. **Identify parallel groups** — tasks with no arrows between them\n4. **Build execution stages** — Stage 1: no prerequisites, Stage 2: depends on Stage 1, etc.\n5. **Define fan-in points** — where parallel results combine\n\n## Error Handling Strategies\n\n| Strategy | Behavior | When to Use |\n|----------|----------|-------------|\n| **Fail fast** | Stop everything on first failure | Build pipelines, CI/CD |\n| **Collect all** | Let all tasks complete, report all failures | Analysis, auditing |\n| **Retry failed** | Re-run failed tasks, keep successes | Flaky tests, network ops |\n\n## Your Exercise\n\nThis project has 3 independent modules: `modules/auth/`, `modules/api/`, and `modules/data/`. Each module has exported functions that lack JSDoc documentation.\n\n**Your task (fan-out, then fan-in):**\n\n1. **Fan-out**: Add JSDoc comments (`/** ... */` with `@param` and/or `@returns`) to all exported functions in all 3 modules:\n   - `modules/auth/index.js` — hashPassword, verifyPassword, generateToken, verifyToken, register, login\n   - `modules/api/index.js` — createRouter (and its inner functions authenticate, requireRole)\n   - `modules/data/index.js` — findAll, findById, findByEmail, create, update, remove\n\n   These 3 files are independent — they can all be documented in parallel.\n\n2. **Fan-in**: After all 3 modules are documented, create `API-REFERENCE.md` that lists every module's public functions with a brief description of each.\n\nRun `/dojo check` when done.",
  "difficulty": "advanced",
  "xpReward": 300,
  "estimatedMinutes": 15,
  "skills": ["workflow-orchestration", "dependency-analysis", "fan-out-fan-in", "documentation"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-15-004",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Multi-Module Project\n\nA project with 3 independent modules (auth, api, data) that need documentation.\n\n## Structure\n\n- `modules/auth/` — Authentication (password hashing, JWT tokens)\n- `modules/api/` — Express API routes and middleware\n- `modules/data/` — Data access layer (CRUD operations)\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"multi-module-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"test\": \"node test/run-all.js\",\n    \"test:auth\": \"node modules/auth/test.js\",\n    \"test:api\": \"node modules/api/test.js\",\n    \"test:data\": \"node modules/data/test.js\"\n  }\n}\n"
      },
      {
        "path": "modules/auth/index.js",
        "content": "const bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst { validateEmail } = require('../data/validators');\n\nconst SALT_ROUNDS = 12;\nconst TOKEN_EXPIRY = '24h';\n\nasync function hashPassword(password) {\n  return bcrypt.hash(password, SALT_ROUNDS);\n}\n\nasync function verifyPassword(password, hash) {\n  return bcrypt.compare(password, hash);\n}\n\nfunction generateToken(user, secret) {\n  return jwt.sign(\n    { id: user.id, email: user.email, role: user.role },\n    secret,\n    { expiresIn: TOKEN_EXPIRY }\n  );\n}\n\nfunction verifyToken(token, secret) {\n  try {\n    return jwt.verify(token, secret);\n  } catch (err) {\n    return null;\n  }\n}\n\nasync function register(userData, db, config) {\n  if (!validateEmail(userData.email)) {\n    throw new Error('Invalid email format');\n  }\n  const existing = await db.findByEmail(userData.email);\n  if (existing) throw new Error('Email already registered');\n\n  const passwordHash = await hashPassword(userData.password);\n  return db.create({ ...userData, passwordHash });\n}\n\nasync function login(email, password, db, config) {\n  const user = await db.findByEmail(email);\n  if (!user) throw new Error('User not found');\n\n  const valid = await verifyPassword(password, user.passwordHash);\n  if (!valid) throw new Error('Invalid credentials');\n\n  const token = generateToken(user, config.jwtSecret);\n  return { token, user: { id: user.id, email: user.email } };\n}\n\nmodule.exports = {\n  hashPassword, verifyPassword, generateToken,\n  verifyToken, register, login\n};\n"
      },
      {
        "path": "modules/auth/config.json",
        "content": "{\n  \"saltRounds\": 12,\n  \"tokenExpiry\": \"24h\",\n  \"maxLoginAttempts\": 5,\n  \"lockoutDuration\": 900,\n  \"passwordMinLength\": 8,\n  \"requireSpecialChar\": true\n}\n"
      },
      {
        "path": "modules/auth/test.js",
        "content": "console.log('[Auth Tests] Running...');\nconsole.log('  PASS: hashPassword produces valid hash');\nconsole.log('  PASS: verifyPassword matches correct password');\nconsole.log('  PASS: verifyPassword rejects wrong password');\nconsole.log('  PASS: generateToken creates valid JWT');\nconsole.log('  PASS: verifyToken decodes valid token');\nconsole.log('  PASS: verifyToken returns null for invalid token');\nconsole.log('  PASS: register rejects duplicate email');\nconsole.log('  PASS: login returns token for valid credentials');\nconsole.log('[Auth Tests] 8/8 passed');\n"
      },
      {
        "path": "modules/api/index.js",
        "content": "const express = require('express');\nconst { verifyToken } = require('../auth');\nconst { findAll, findById, create, update, remove } = require('../data');\n\nfunction createRouter(config) {\n  const router = express.Router();\n\n  function authenticate(req, res, next) {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).json({ error: 'No token provided' });\n\n    const decoded = verifyToken(token, config.jwtSecret);\n    if (!decoded) return res.status(401).json({ error: 'Invalid token' });\n\n    req.user = decoded;\n    next();\n  }\n\n  function requireRole(role) {\n    return (req, res, next) => {\n      if (req.user.role !== role) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      next();\n    };\n  }\n\n  router.get('/users', authenticate, async (req, res) => {\n    const users = await findAll('users');\n    res.json(users);\n  });\n\n  router.get('/users/:id', authenticate, async (req, res) => {\n    const user = await findById('users', req.params.id);\n    if (!user) return res.status(404).json({ error: 'Not found' });\n    res.json(user);\n  });\n\n  router.get('/products', async (req, res) => {\n    const products = await findAll('products');\n    res.json(products);\n  });\n\n  router.post('/products', authenticate, requireRole('admin'), async (req, res) => {\n    const product = await create('products', req.body);\n    res.status(201).json(product);\n  });\n\n  router.get('/orders', authenticate, async (req, res) => {\n    const orders = await findAll('orders', { userId: req.user.id });\n    res.json(orders);\n  });\n\n  router.post('/orders', authenticate, async (req, res) => {\n    const order = await create('orders', { ...req.body, userId: req.user.id });\n    res.status(201).json(order);\n  });\n\n  return router;\n}\n\nmodule.exports = { createRouter };\n"
      },
      {
        "path": "modules/api/config.json",
        "content": "{\n  \"port\": 3000,\n  \"host\": \"0.0.0.0\",\n  \"cors\": {\n    \"origin\": [\"http://localhost:8080\"],\n    \"methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n  },\n  \"rateLimit\": {\n    \"windowMs\": 900000,\n    \"max\": 100\n  }\n}\n"
      },
      {
        "path": "modules/api/test.js",
        "content": "console.log('[API Tests] Running...');\nconsole.log('  PASS: GET /users requires authentication');\nconsole.log('  PASS: GET /users returns user list');\nconsole.log('  PASS: GET /users/:id returns single user');\nconsole.log('  PASS: GET /products is public');\nconsole.log('  PASS: POST /products requires admin role');\nconsole.log('  PASS: GET /orders scoped to current user');\nconsole.log('  PASS: POST /orders creates with user ID');\nconsole.log('[API Tests] 7/7 passed');\n"
      },
      {
        "path": "modules/data/index.js",
        "content": "const { validateSchema } = require('./validators');\n\nconst store = {\n  users: [],\n  products: [],\n  orders: []\n};\n\nasync function findAll(collection, filters = {}) {\n  let results = store[collection] || [];\n  for (const [key, value] of Object.entries(filters)) {\n    results = results.filter(item => item[key] === value);\n  }\n  return results;\n}\n\nasync function findById(collection, id) {\n  return (store[collection] || []).find(item => item.id === id);\n}\n\nasync function findByEmail(email) {\n  return store.users.find(u => u.email === email);\n}\n\nasync function create(collection, data) {\n  const validated = validateSchema(collection, data);\n  const id = (store[collection]?.length || 0) + 1;\n  const record = { id, ...validated, createdAt: new Date().toISOString() };\n  store[collection].push(record);\n  return record;\n}\n\nasync function update(collection, id, data) {\n  const index = store[collection].findIndex(item => item.id === id);\n  if (index === -1) throw new Error('Record not found');\n  store[collection][index] = { ...store[collection][index], ...data };\n  return store[collection][index];\n}\n\nasync function remove(collection, id) {\n  const index = store[collection].findIndex(item => item.id === id);\n  if (index === -1) throw new Error('Record not found');\n  return store[collection].splice(index, 1)[0];\n}\n\nmodule.exports = {\n  findAll, findById, findByEmail, create, update, remove\n};\n"
      },
      {
        "path": "modules/data/validators.js",
        "content": "const schemas = {\n  users: {\n    required: ['name', 'email', 'passwordHash'],\n    optional: ['role']\n  },\n  products: {\n    required: ['name', 'price'],\n    optional: ['category', 'description']\n  },\n  orders: {\n    required: ['userId', 'items'],\n    optional: ['status', 'total']\n  }\n};\n\nfunction validateEmail(email) {\n  const pattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return pattern.test(email);\n}\n\nfunction validateSchema(collection, data) {\n  const schema = schemas[collection];\n  if (!schema) throw new Error(`Unknown collection: ${collection}`);\n\n  for (const field of schema.required) {\n    if (data[field] === undefined) {\n      throw new Error(`Missing required field: ${field}`);\n    }\n  }\n\n  const allowedFields = [...schema.required, ...schema.optional];\n  const filtered = {};\n  for (const field of allowedFields) {\n    if (data[field] !== undefined) filtered[field] = data[field];\n  }\n  return filtered;\n}\n\nmodule.exports = { validateEmail, validateSchema };\n"
      },
      {
        "path": "modules/data/config.json",
        "content": "{\n  \"database\": {\n    \"host\": \"localhost\",\n    \"port\": 5432,\n    \"name\": \"app_development\",\n    \"pool\": { \"min\": 2, \"max\": 10 }\n  },\n  \"cache\": {\n    \"enabled\": true,\n    \"ttl\": 300\n  }\n}\n"
      },
      {
        "path": "modules/data/test.js",
        "content": "console.log('[Data Tests] Running...');\nconsole.log('  PASS: findAll returns all records');\nconsole.log('  PASS: findAll filters by criteria');\nconsole.log('  PASS: findById returns correct record');\nconsole.log('  PASS: create validates required fields');\nconsole.log('  PASS: create rejects missing fields');\nconsole.log('  PASS: update modifies existing record');\nconsole.log('  PASS: remove deletes record');\nconsole.log('  PASS: validateEmail accepts valid format');\nconsole.log('  PASS: validateSchema enforces required fields');\nconsole.log('[Data Tests] 9/9 passed');\n"
      },
      {
        "path": "test/run-all.js",
        "content": "console.log('Running all test suites...\\n');\nrequire('../modules/auth/test');\nconsole.log();\nrequire('../modules/api/test');\nconsole.log();\nrequire('../modules/data/test');\nconsole.log('\\n=== All 24 tests passed! ===');\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Auth module has JSDoc comments",
      "type": "file_contains",
      "target": "modules/auth/index.js",
      "pattern": "/\\*\\*|@param|@returns",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "API module has JSDoc comments",
      "type": "file_contains",
      "target": "modules/api/index.js",
      "pattern": "/\\*\\*|@param|@returns",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Data module has JSDoc comments",
      "type": "file_contains",
      "target": "modules/data/index.js",
      "pattern": "/\\*\\*|@param|@returns",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "API reference document exists",
      "type": "file_exists",
      "target": "API-REFERENCE.md",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "API reference lists functions from all modules",
      "type": "file_contains",
      "target": "API-REFERENCE.md",
      "pattern": "hashPassword|generateToken|login",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "API reference includes API and data module functions",
      "type": "file_contains",
      "target": "API-REFERENCE.md",
      "pattern": "createRouter|findAll|findById",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Data validators also have JSDoc",
      "type": "file_contains",
      "target": "modules/data/validators.js",
      "pattern": "/\\*\\*|@param|@returns",
      "xpBonus": 50
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "The 3 module files (modules/auth/index.js, modules/api/index.js, modules/data/index.js) are completely independent. Add JSDoc to all exported functions in each file -- these can be edited in parallel. Then create API-REFERENCE.md listing every public function.",
      "xpCost": 20
    },
    {
      "level": 2,
      "text": "For JSDoc, add /** ... */ blocks before each exported function with @param and @returns tags. For example: /** Hash a password using bcrypt\\n * @param {string} password - The plaintext password\\n * @returns {Promise<string>} The hashed password */. After all 3 files are documented, create API-REFERENCE.md with sections for each module listing its functions and descriptions.",
      "xpCost": 60
    },
    {
      "level": 3,
      "text": "Ask Claude: 'Add JSDoc comments (with @param and @returns) to all exported functions in modules/auth/index.js, modules/api/index.js, and modules/data/index.js. These are independent files so edit them all. Then create API-REFERENCE.md with a section for each module listing all public functions: Auth (hashPassword, verifyPassword, generateToken, verifyToken, register, login), API (createRouter), Data (findAll, findById, findByEmail, create, update, remove). Include a brief description of each function.'",
      "xpCost": 120
    }
  ],

  "solution": {
    "approach": "Fan-out: add JSDoc to all 3 module index.js files in parallel. Fan-in: create API-REFERENCE.md listing all public functions from all modules.",
    "example": "Edit 3 files in parallel to add JSDoc, then create API-REFERENCE.md with sections for auth (hashPassword, generateToken, login, etc.), api (createRouter), and data (findAll, findById, create, etc.).",
    "alternativeApproaches": [
      "Document one module at a time, then combine into the reference",
      "Use background subagents to analyze each module, then synthesize the reference"
    ]
  },

  "learningPoints": [
    "Fan-out launches multiple independent tasks in parallel -- editing 3 independent files simultaneously",
    "Fan-in waits for all parallel tasks to complete and combines their results into a unified output",
    "Dependency chains define strict ordering: the API reference can only be created after all modules are documented",
    "Real workflows are mixed: fan-out for independent work, then fan-in to combine, then sequential for the final output",
    "Always plan your error handling strategy: fail-fast stops on first failure, collect-all continues and reports everything",
    "Designing the workflow before executing it (listing tasks, mapping dependencies, identifying stages) leads to more efficient execution"
  ],

  "nextChallenge": "16-001"
}
