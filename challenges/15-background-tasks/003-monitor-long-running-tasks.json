{
  "id": "15-003",
  "module": "background-tasks",
  "title": "Monitor Long-Running Tasks",
  "description": "Learn the full lifecycle of background tasks and the tools for monitoring them, then practice by running a build in the background while fixing a bug.\n\n## Task Lifecycle\n\nEvery background task in Claude Code goes through 3 states:\n\n```\n[Launched] --> [Running] --> [Completed]\n                  |               |\n                  v               v\n            (output file      (exit code\n             grows over        available)\n             time)\n```\n\n1. **Launched**: The Bash or Task tool runs with `run_in_background: true`. Claude Code receives a **task ID** and **output file path** immediately.\n2. **Running**: The command executes in a separate process. stdout/stderr are written to the output file continuously.\n3. **Completed**: The process exits. Full output is available. Exit code indicates success (0) or failure (non-zero).\n\n## 4 Monitoring Methods\n\n### Method 1: TaskOutput Tool (Non-Blocking)\n```\nTaskOutput:\n  task_id: \"the-id\"\n  block: false\n```\nReturns immediately with current status and whatever output exists so far. Perfect for quick \"is it done yet?\" checks.\n\n### Method 2: TaskOutput Tool (Blocking)\n```\nTaskOutput:\n  task_id: \"the-id\"\n  block: true\n```\nWaits until the task completes, then returns all output. Use when you've reached a point where you need the result.\n\n### Method 3: Read the Output File\n```\nRead tool:\n  file_path: \"/path/to/output/file\"\n```\nShows everything written so far. Good for seeing full output including earlier lines.\n\n### Method 4: tail via Bash\n```\nBash tool:\n  command: \"tail -20 /path/to/output/file\"\n```\nQuick peek at the most recent output. Useful when output is very long.\n\n## Monitoring Patterns\n\n| Pattern | How It Works | Best For |\n|---------|-------------|----------|\n| **Fire and Check** | Launch task, do other work, check when needed | Having productive parallel work |\n| **Periodic Progress** | Launch task, peek at output periodically | Long tasks you want to track |\n| **Wait When Ready** | Launch task, do other work, then block until done | Fixed amount of parallel work |\n\n## Handling Stuck Tasks\n\n- **Check output growth**: Read the output file twice -- if it's not growing, the task may be stuck\n- **Bash timeout**: Set timeout in the Bash tool parameters (up to 600000ms / 10 minutes)\n- **Kill the process**: Use `ps` and `kill` via Bash as a last resort\n\n## Your Exercise\n\nThis project has a build script (`scripts/build.js`) that takes several seconds and generates `dist/bundle.js`. The source file `src/routes.js` has a bug: **none of the route handlers have error handling**. If a database call fails, the server crashes.\n\n**Your task:**\n1. Run the build script (`node scripts/build.js`) in the background\n2. While the build is running, fix `src/routes.js` by adding try/catch to the route handlers (each catch should send `res.status(500).json({ error: error.message })`)\n3. After the build completes, verify that `dist/bundle.js` was generated\n\nThis exercises the real skill: **doing productive work while a background task runs**.\n\nRun `/dojo check` when done.",
  "difficulty": "intermediate",
  "xpReward": 200,
  "estimatedMinutes": 12,
  "skills": ["task-monitoring", "process-management", "task-lifecycle"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-15-003",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Build & Fix Project\n\nA Node.js project with a build script and route handlers that need error handling.\n\n## Structure\n\n- `src/` — Source files (server, routes, config, handlers)\n- `scripts/` — Build and utility scripts\n- `dist/` — Generated by the build script\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"build-fix-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"build\": \"node scripts/build.js\",\n    \"test\": \"node scripts/test-suite.js\",\n    \"start\": \"node src/server.js\"\n  }\n}\n"
      },
      {
        "path": "src/server.js",
        "content": "const http = require('http');\nconst { loadConfig } = require('./config');\nconst { setupRoutes } = require('./routes');\n\nconst config = loadConfig();\nconst app = http.createServer((req, res) => {\n  setupRoutes(req, res, config);\n});\n\nconst PORT = config.port || 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n"
      },
      {
        "path": "src/config.js",
        "content": "function loadConfig() {\n  return {\n    port: process.env.PORT || 3000,\n    dbUrl: process.env.DATABASE_URL || 'postgres://localhost/app',\n    environment: process.env.NODE_ENV || 'development'\n  };\n}\n\nmodule.exports = { loadConfig };\n"
      },
      {
        "path": "src/routes.js",
        "content": "const { getUsers, createUser } = require('./handlers/users');\nconst { getOrders } = require('./handlers/orders');\n\nfunction setupRoutes(req, res, config) {\n  const url = req.url;\n  const method = req.method;\n\n  if (url === '/api/users' && method === 'GET') {\n    return getUsers(req, res);\n  }\n  if (url === '/api/users' && method === 'POST') {\n    return createUser(req, res);\n  }\n  if (url === '/api/orders' && method === 'GET') {\n    return getOrders(req, res);\n  }\n\n  res.writeHead(404);\n  res.end(JSON.stringify({ error: 'Not found' }));\n}\n\nmodule.exports = { setupRoutes };\n"
      },
      {
        "path": "src/handlers/users.js",
        "content": "async function getUsers(req, res) {\n  const users = await db.query('SELECT id, name, email FROM users');\n  res.writeHead(200, { 'Content-Type': 'application/json' });\n  res.end(JSON.stringify(users));\n}\n\nasync function createUser(req, res) {\n  let body = '';\n  req.on('data', chunk => { body += chunk; });\n  req.on('end', async () => {\n    const { name, email } = JSON.parse(body);\n    const user = await db.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email]);\n    res.writeHead(201, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify(user));\n  });\n}\n\nmodule.exports = { getUsers, createUser };\n"
      },
      {
        "path": "src/handlers/orders.js",
        "content": "async function getOrders(req, res) {\n  const orders = await db.query('SELECT * FROM orders');\n  res.writeHead(200, { 'Content-Type': 'application/json' });\n  res.end(JSON.stringify(orders));\n}\n\nmodule.exports = { getOrders };\n"
      },
      {
        "path": "scripts/build.js",
        "content": "const fs = require('fs');\nconst path = require('path');\n\nconst distDir = path.join(__dirname, '..', 'dist');\n\nconsole.log('[Build] Starting build process...');\nconsole.log('[Build] Step 1/4: Checking dependencies...');\n\nsetTimeout(() => {\n  console.log('[Build] Step 2/4: Compiling source files...');\n  setTimeout(() => {\n    console.log('[Build] Step 3/4: Bundling modules...');\n    setTimeout(() => {\n      console.log('[Build] Step 4/4: Writing output...');\n      if (!fs.existsSync(distDir)) {\n        fs.mkdirSync(distDir, { recursive: true });\n      }\n      const content = '// Bundled output\\n// Generated at ' + new Date().toISOString() + '\\n';\n      fs.writeFileSync(path.join(distDir, 'bundle.js'), content);\n      console.log('[Build] Build completed successfully!');\n      console.log('[Build] Output: dist/bundle.js');\n    }, 1500);\n  }, 2000);\n}, 1000);\n"
      },
      {
        "path": "scripts/test-suite.js",
        "content": "console.log('[Test] Starting test suite...');\nconsole.log('[Test] Running unit tests...');\n\nsetTimeout(() => {\n  console.log('[Test]   PASS: user creation');\n  console.log('[Test]   PASS: user validation');\n  console.log('[Test]   PASS: order calculation');\n  setTimeout(() => {\n    console.log('[Test] Running integration tests...');\n    console.log('[Test]   PASS: API /users endpoint');\n    console.log('[Test]   PASS: API /orders endpoint');\n    console.log('[Test] All 5 tests passed!');\n  }, 1500);\n}, 1000);\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Route handlers have error handling (try/catch added)",
      "type": "file_contains",
      "target": "src/routes.js",
      "pattern": "try|catch",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Build output was generated (dist/bundle.js exists)",
      "type": "file_exists",
      "target": "dist/bundle.js",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Error handling also added to handler files (users.js or orders.js)",
      "type": "file_contains",
      "target": "src/handlers/users.js",
      "pattern": "try|catch",
      "xpBonus": 40
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Run the build in the background: 'Run node scripts/build.js in the background.' Then while it runs, fix src/routes.js by wrapping the route handler calls in try/catch blocks that send 500 status on error. After the build completes, check that dist/bundle.js exists.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "For src/routes.js, wrap each route handler call in a try/catch. For example: try { return await getUsers(req, res); } catch (error) { res.writeHead(500); res.end(JSON.stringify({ error: error.message })); }. Make the setupRoutes function async or wrap individual calls. The build script takes about 5 seconds so you have time to make the edit while it runs.",
      "xpCost": 40
    },
    {
      "level": 3,
      "text": "Ask Claude: '1. Run node scripts/build.js in the background. 2. While the build runs, add try/catch error handling to src/routes.js. Each route handler call (getUsers, createUser, getOrders) should be wrapped in try/catch where the catch block sends res.writeHead(500) and res.end(JSON.stringify({ error: error.message })). 3. After the build completes, verify dist/bundle.js was created.'",
      "xpCost": 80
    }
  ],

  "solution": {
    "approach": "Run build in background, fix routes.js error handling while build runs, verify build output exists after completion.",
    "example": "Launch background build, add try/catch to all route handlers in routes.js, verify dist/bundle.js was created.",
    "alternativeApproaches": [
      "Fix the routes first, then run the build (works but misses the background task practice)",
      "Run build in background, fix handlers in users.js and orders.js instead of routes.js"
    ]
  },

  "learningPoints": [
    "Background tasks follow a lifecycle: launched (task ID returned) -> running (output accumulates) -> completed (exit code available)",
    "TaskOutput with block: false gives an immediate status check; block: true waits for completion",
    "The Read tool on the output file shows full accumulated output; tail via Bash shows just the latest lines",
    "Choose your monitoring pattern based on the situation: fire-and-check for productive multitasking, periodic for progress tracking, blocking wait when you need the result to proceed",
    "Detect stuck tasks by checking if the output file is still growing; use the Bash timeout parameter or kill the process if needed"
  ],

  "nextChallenge": "15-004"
}
