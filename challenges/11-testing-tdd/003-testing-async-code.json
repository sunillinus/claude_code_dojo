{
  "id": "11-003",
  "module": "testing-tdd",
  "title": "Testing Async Code",
  "description": "Learn to test asynchronous functions including promises, async/await, error rejection, and timeout racing patterns.",
  "difficulty": "intermediate",
  "xpReward": 225,
  "estimatedMinutes": 20,
  "skills": ["async-testing", "promises", "error-handling", "test-patterns"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-11-003",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Testing Async Code\n\nLearn to write reliable tests for asynchronous functions, including\npromises, error rejection, retries, and timeout patterns.\n\n## Why Async Testing is Different\n\nSynchronous code executes top-to-bottom and returns immediately.\nAsync code returns a Promise that resolves later. If you forget to\n`await` in a test, the test will PASS even if the assertion would\nfail -- because the assertion runs after the test has already\ncompleted. This is the #1 async testing pitfall.\n\n## async/await in Tests\n\nNode.js test runner supports async test functions natively. Just\nmake your test callback `async` and `await` the results:\n\n```javascript\nconst { test } = require('node:test');\nconst assert = require('node:assert');\n\n// CORRECT: async test with await\ntest('fetches user data', async () => {\n  const user = await fetchUser(1);\n  assert.strictEqual(user.name, 'Alice');\n});\n\n// WRONG: missing await - test passes even if fetchUser rejects!\ntest('broken test - NEVER do this', () => {\n  fetchUser(1).then(user => {\n    assert.strictEqual(user.name, 'Alice');\n  });\n  // Test function returns before .then() runs!\n});\n```\n\n## Testing Promise Resolution\n\nFor functions that return promises, use `async/await` to get the\nresolved value and assert on it:\n\n```javascript\ntest('fetchUser resolves with user object', async () => {\n  const user = await fetchUser(1);\n  assert.strictEqual(user.id, 1);\n  assert.ok(user.name);  // name exists and is truthy\n  assert.ok(user.email); // email exists and is truthy\n});\n```\n\n## Testing Promise Rejection\n\nWhen async functions should throw errors, use `assert.rejects()`.\nThis is the async equivalent of `assert.throws()`:\n\n```javascript\n// assert.rejects takes an async function (or Promise) and verifies it rejects\ntest('fetchUser rejects for invalid ID', async () => {\n  await assert.rejects(\n    async () => await fetchUser(-1),\n    { message: /Invalid user ID/ }  // optional: match error message\n  );\n});\n\n// You can also match the error class\ntest('rejects with Error type', async () => {\n  await assert.rejects(\n    async () => await fetchUser(-1),\n    Error  // verify it's an Error instance\n  );\n});\n```\n\nIMPORTANT: Always `await` the `assert.rejects()` call! Without\nawait, the test will pass even if the function does NOT reject.\n\n## Testing Timeout/Racing Patterns\n\nA common async pattern is racing a promise against a timeout:\n\n```javascript\ntest('withTimeout rejects if promise is too slow', async () => {\n  const slowPromise = new Promise(resolve =>\n    setTimeout(() => resolve('done'), 5000)\n  );\n  await assert.rejects(\n    async () => await withTimeout(slowPromise, 100),\n    { message: /timed out/i }\n  );\n});\n\ntest('withTimeout resolves if promise is fast enough', async () => {\n  const fastPromise = new Promise(resolve =>\n    setTimeout(() => resolve('done'), 10)\n  );\n  const result = await withTimeout(fastPromise, 1000);\n  assert.strictEqual(result, 'done');\n});\n```\n\n## Testing Retry Logic\n\nFor functions that retry on failure, you need to verify:\n- It eventually succeeds when retries are sufficient\n- It fails after exhausting all retries\n- It calls the underlying function the right number of times\n\n```javascript\ntest('fetchWithRetry succeeds after transient failures', async () => {\n  let attempts = 0;\n  const flakyFn = async () => {\n    attempts++;\n    if (attempts < 3) throw new Error('Transient error');\n    return 'success';\n  };\n  const result = await fetchWithRetry(flakyFn, 3);\n  assert.strictEqual(result, 'success');\n  assert.strictEqual(attempts, 3);\n});\n```\n\n## Testing Sequential Processing\n\nWhen testing functions that process items sequentially (one at a\ntime, in order), verify both the results and the order:\n\n```javascript\ntest('batchProcess processes items in order', async () => {\n  const order = [];\n  const processFn = async (item) => {\n    order.push(item);\n    return item * 2;\n  };\n  const results = await batchProcess([1, 2, 3], processFn);\n  assert.deepStrictEqual(results, [2, 4, 6]);\n  assert.deepStrictEqual(order, [1, 2, 3]); // processed in order\n});\n```\n\n## Common Pitfalls\n\n| Pitfall | Symptom | Fix |\n|---------|---------|-----|\n| Forgetting `await` | Test passes when it should fail | Always `await` async assertions |\n| Forgetting `async` | `await` becomes a no-op | Always use `async () => {}` |\n| Not awaiting `assert.rejects` | Rejection is uncaught | `await assert.rejects(...)` |\n| Test timeout too short | Tests fail intermittently | Increase timeout or mock timers |\n| Testing timing, not behavior | Tests are flaky | Avoid exact timing checks |\n\n## Your Task\n\nThe file `dataService.js` contains 4 async functions with NO tests:\n\n1. `fetchUser(id)` - Fetches a user by ID, rejects for invalid IDs\n2. `fetchWithRetry(fn, maxRetries)` - Retries a failing async function\n3. `batchProcess(items, processFn)` - Processes items sequentially\n4. `withTimeout(promise, ms)` - Races a promise against a timeout\n\nWrite comprehensive async tests for ALL 4 functions. For each, test:\n- The success/happy path\n- Error/rejection cases\n- Edge cases specific to that function\n\n## Objectives\n1. Create `dataService.test.js` with async tests for all 4 functions\n2. Use `async/await` in all test functions\n3. Use `assert.rejects()` for error/rejection cases\n4. Test the timeout behavior of `withTimeout`\n5. All tests pass when you run `npm test`\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"async-testing-challenge\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"test\": \"node --test\"\n  }\n}\n"
      },
      {
        "path": "dataService.js",
        "content": "/**\n * Simulates fetching a user from a database.\n * @param {number} id - The user ID (must be a positive integer)\n * @returns {Promise<Object>} The user object\n * @throws {Error} If id is not a positive integer\n */\nasync function fetchUser(id) {\n  // Simulate network delay\n  await delay(50);\n\n  if (!Number.isInteger(id) || id <= 0) {\n    throw new Error('Invalid user ID: must be a positive integer');\n  }\n\n  return {\n    id,\n    name: `User_${id}`,\n    email: `user${id}@example.com`,\n    createdAt: '2024-01-15T10:30:00Z'\n  };\n}\n\n/**\n * Retries an async function up to maxRetries times on failure.\n * @param {Function} fn - An async function to call\n * @param {number} maxRetries - Maximum number of retry attempts\n * @returns {Promise<*>} The result of fn()\n * @throws {Error} The last error if all retries are exhausted\n */\nasync function fetchWithRetry(fn, maxRetries) {\n  let lastError;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const result = await fn();\n      return result;\n    } catch (err) {\n      lastError = err;\n      if (attempt < maxRetries) {\n        await delay(10); // Small delay between retries\n      }\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Processes an array of items sequentially using the provided function.\n * Each item is processed one at a time, in order.\n * @param {Array} items - Items to process\n * @param {Function} processFn - Async function to apply to each item\n * @returns {Promise<Array>} Array of results in the same order\n */\nasync function batchProcess(items, processFn) {\n  const results = [];\n\n  for (const item of items) {\n    const result = await processFn(item);\n    results.push(result);\n  }\n\n  return results;\n}\n\n/**\n * Races a promise against a timeout.\n * @param {Promise} promise - The promise to race\n * @param {number} ms - Timeout in milliseconds\n * @returns {Promise<*>} The result of the promise if it resolves in time\n * @throws {Error} 'Operation timed out' if the timeout expires first\n */\nfunction withTimeout(promise, ms) {\n  const timeout = new Promise((_, reject) =>\n    setTimeout(() => reject(new Error('Operation timed out')), ms)\n  );\n  return Promise.race([promise, timeout]);\n}\n\n/**\n * Utility: creates a delay.\n * @param {number} ms - Milliseconds to wait\n * @returns {Promise<void>}\n */\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nmodule.exports = { fetchUser, fetchWithRetry, batchProcess, withTimeout, delay };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create a test file for the data service",
      "type": "file_exists",
      "target": "dataService.test.js",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Use async test functions",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "async",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Test fetchUser success case",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "fetchUser",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Test fetchUser rejection for invalid ID using assert.rejects",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "assert\\.rejects",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Test fetchWithRetry function",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "fetchWithRetry|retry",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "Test batchProcess function",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "batchProcess|batch",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "Test withTimeout function",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "withTimeout|timeout|timed out",
      "required": true
    },
    {
      "id": "obj-8",
      "description": "All tests pass",
      "type": "command_output_contains",
      "command": "cd ~/dojo-workspace/challenge-11-003 && npm test 2>&1",
      "pattern": "pass|ok",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Test that fetchWithRetry exhausts all retries before throwing",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "attempts|exhaust|all retries|maxRetries",
      "xpBonus": 40
    },
    {
      "id": "bonus-2",
      "description": "Test that batchProcess handles empty array",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "empty|\\[\\s*\\]",
      "xpBonus": 30
    },
    {
      "id": "bonus-3",
      "description": "Test that withTimeout resolves when promise is fast enough",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "resolves|fast|in time|before timeout",
      "xpBonus": 30
    },
    {
      "id": "bonus-4",
      "description": "Use describe blocks to organize tests by function",
      "type": "file_contains",
      "target": "dataService.test.js",
      "pattern": "describe",
      "xpBonus": 25
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Every test that calls an async function must be declared as `async () => {}` and must `await` the function call. For error tests, use `await assert.rejects(async () => await fn(), ...)`. For fetchWithRetry, create a counter variable and a function that fails the first N times but succeeds after that. For withTimeout, create a slow promise (long setTimeout) and a fast promise (short setTimeout) to test both paths.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "For each function, test at least: fetchUser - valid ID returns object with correct fields, invalid ID (0, -1, 'abc') rejects. fetchWithRetry - succeeds on first try, succeeds after N failures, fails when all retries exhausted. batchProcess - processes items in order, returns correct results array, handles empty array. withTimeout - rejects when promise is too slow, resolves when promise is fast enough.",
      "xpCost": 45
    },
    {
      "level": 3,
      "text": "Ask Claude: 'Create dataService.test.js with comprehensive async tests for all 4 functions in dataService.js. Use describe blocks to group by function. For fetchUser: test valid ID returns user object, invalid ID rejects with Error. For fetchWithRetry: use a counter-based mock function that fails N times then succeeds, test success after retries, test failure when retries exhausted. For batchProcess: test sequential processing with order verification, test empty array. For withTimeout: test that slow promises cause timeout rejection, test that fast promises resolve normally. Use assert.rejects for all rejection tests. Always await assertions.'",
      "xpCost": 90
    }
  ],

  "solution": {
    "approach": "Create dataService.test.js with async test functions. For each of the 4 functions, write tests for success path, error/rejection path, and edge cases. Use assert.rejects() for rejection tests. Create mock/stub functions for retry and batch testing. Always use async/await.",
    "example": "Write async tests for all 4 data service functions covering success, failure, and edge cases",
    "alternativeApproaches": [
      "Use try/catch blocks instead of assert.rejects for rejection testing",
      "Create shared helper functions for common test patterns",
      "Test functions in isolation or test integration between them"
    ]
  },

  "learningPoints": [
    "Async tests must use `async () => {}` and `await` all async operations",
    "Forgetting await is the #1 async testing pitfall - the test passes falsely",
    "Use assert.rejects() for testing that async functions throw/reject (and always await it)",
    "For retry testing, create counter-based mock functions that fail N times then succeed",
    "Promise.race patterns (timeouts) need both fast-path and slow-path tests",
    "batchProcess-style sequential tests should verify both results AND processing order"
  ],

  "nextChallenge": "11-004"
}