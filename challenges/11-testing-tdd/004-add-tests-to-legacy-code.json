{
  "id": "11-004",
  "module": "testing-tdd",
  "title": "Add Tests to Legacy Code",
  "description": "Learn to add tests to existing code that has no tests. Write characterization tests to capture current behavior before making any changes.",
  "difficulty": "intermediate",
  "xpReward": 250,
  "estimatedMinutes": 20,
  "skills": ["legacy-testing", "characterization-tests", "test-seams", "behavior-documentation"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-11-004",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Add Tests to Legacy Code\n\nLearn to add tests to an existing codebase that has zero test coverage.\nThis is one of the most common and valuable real-world testing skills.\n\n## What is Legacy Code?\n\nMichael Feathers, in his book \"Working Effectively with Legacy Code\",\ndefines legacy code simply as: **code without tests**.\n\nIt does not matter if the code was written yesterday or ten years ago.\nIf there are no tests, it is legacy code -- because you cannot safely\nchange it without risking breakage you won't detect.\n\n## Characterization Tests\n\nWhen you encounter code without tests, your first instinct might be to\nfix things. **Don't.** First, you need to understand what the code\nactually does -- not what you think it should do.\n\nCharacterization tests capture the CURRENT behavior of the code, even\nif that behavior is wrong. The goal is to create a safety net so that\nwhen you DO make changes later, you will know if you broke anything.\n\n### The Process\n\n1. **Read the code** and form a hypothesis about what it does\n2. **Write a test** that calls the function with specific inputs\n3. **Run the test** and see what ACTUALLY happens\n4. **Adjust your test** to match the actual output (not your expectation)\n5. **Repeat** for different inputs and code paths\n\nExample:\n```javascript\n// You think calculateTax(100) should return 7.00 (7% tax)\n// But the code actually returns 7.50 (it uses 7.5%)\n// Your characterization test should assert 7.50, not 7.00\n// The point is to capture what the code DOES, not what it SHOULD do\ntest('calculateTax uses 7.5% rate', () => {\n  assert.strictEqual(calculateTax(100), 7.50);\n});\n```\n\n## Why Characterization Tests First?\n\nYou might ask: \"Why not just fix the bugs?\"\n\n1. **You might be wrong** about what's a bug. That 7.5% rate might be\n   correct for the business domain. Without domain knowledge, you\n   cannot distinguish bugs from features.\n2. **Other code depends on current behavior.** If another module\n   expects 7.50, \"fixing\" it to 7.00 breaks that module.\n3. **You need a baseline.** Without tests capturing current behavior,\n   how will you know if your \"fix\" introduced new problems?\n\n## Finding Test Seams\n\nA \"seam\" is a place in the code where you can alter behavior without\nediting the code itself. Common seams:\n\n- **Function parameters**: Pass different arguments\n- **Module exports**: Test the public interface\n- **Constructor injection**: Pass mock dependencies\n- **Environmental**: Set environment variables\n\nAlways test through the public API first. Avoid reaching into private\nimplementation details.\n\n## Testing Strategy for Legacy Code\n\n1. **Start with the public API** - test the exported functions\n2. **Test the happy path first** - normal inputs, expected behavior\n3. **Then test the branches** - if/else paths, error conditions\n4. **Document surprises** - when behavior differs from expectation\n5. **Don't change the code** - tests should pass against existing code\n\n## The Strangler Fig Pattern for Testing\n\nNamed after strangler fig trees that grow around existing trees:\n1. Write characterization tests for existing code\n2. Write NEW code with its own tests alongside\n3. Gradually redirect callers from old to new\n4. Old code shrinks as new tested code grows\n\n## Identifying Questionable Behavior\n\nAs you write characterization tests, you will notice behaviors that\nseem wrong. Document them, but DO NOT fix them yet. Create a file\nlike `FINDINGS.md` that lists:\n- What the behavior is\n- Why you think it might be wrong\n- What the expected behavior might be\n- Which test demonstrates it\n\nThis becomes a roadmap for future fixes.\n\n## Your Task\n\nThe file `orderProcessor.js` is a legacy module (~120 lines) that\nprocesses customer orders. It:\n- Validates order items\n- Calculates prices with tax and discounts\n- Generates invoice strings\n\nIt has NO tests. Some behavior is intentional, some is questionable.\nYour job:\n\n1. Write characterization tests in `orderProcessor.test.js` that\n   capture the CURRENT behavior of all exported functions\n2. Your tests must PASS against the existing code (don't change it!)\n3. Create `FINDINGS.md` documenting at least one questionable behavior\n   you discovered while testing\n\n## Objectives\n1. Create `orderProcessor.test.js` with tests for all exported functions\n2. Tests must pass against the existing (unmodified) code\n3. Test the main code paths: valid orders, invalid orders, discounts\n4. Create `FINDINGS.md` documenting questionable behavior\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"legacy-testing-challenge\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"test\": \"node --test\"\n  }\n}\n"
      },
      {
        "path": "orderProcessor.js",
        "content": "// Order Processing Module\n// Written by: previous developer (no longer on team)\n// Last modified: unknown\n// Tests: none\n\nconst TAX_RATE = 0.08;\nconst BULK_DISCOUNT_THRESHOLD = 5;\nconst BULK_DISCOUNT_RATE = 0.10;\nconst MEMBER_DISCOUNT_RATE = 0.05;\n\nfunction validateItem(item) {\n  if (!item.name || typeof item.name !== 'string') {\n    return { valid: false, error: 'Item name is required' };\n  }\n  if (typeof item.price !== 'number' || item.price < 0) {\n    return { valid: false, error: 'Item price must be a non-negative number' };\n  }\n  if (!Number.isInteger(item.quantity) || item.quantity < 1) {\n    return { valid: false, error: 'Item quantity must be a positive integer' };\n  }\n  return { valid: true };\n}\n\nfunction validateOrder(order) {\n  const errors = [];\n\n  if (!order || !order.items || !Array.isArray(order.items)) {\n    return { valid: false, errors: ['Order must have an items array'] };\n  }\n\n  if (order.items.length === 0) {\n    return { valid: false, errors: ['Order must have at least one item'] };\n  }\n\n  for (let i = 0; i < order.items.length; i++) {\n    const result = validateItem(order.items[i]);\n    if (!result.valid) {\n      errors.push(`Item ${i}: ${result.error}`);\n    }\n  }\n\n  return errors.length > 0\n    ? { valid: false, errors }\n    : { valid: true, errors: [] };\n}\n\nfunction calculateSubtotal(items) {\n  let subtotal = 0;\n  for (const item of items) {\n    subtotal += item.price * item.quantity;\n  }\n  // QUIRK: rounds to nearest cent using Math.round instead of proper\n  // financial rounding. This can cause 1-cent discrepancies.\n  return Math.round(subtotal * 100) / 100;\n}\n\nfunction calculateDiscount(subtotal, order) {\n  let discount = 0;\n\n  // Bulk discount: 10% off if any single item has quantity >= 5\n  const hasBulkItem = order.items.some(item => item.quantity >= BULK_DISCOUNT_THRESHOLD);\n  if (hasBulkItem) {\n    discount += subtotal * BULK_DISCOUNT_RATE;\n  }\n\n  // Member discount: additional 5% off for members\n  // BUG: member discount is applied to original subtotal, not the\n  // discounted amount. This means members get slightly more discount\n  // than intended when combined with bulk discount.\n  if (order.isMember) {\n    discount += subtotal * MEMBER_DISCOUNT_RATE;\n  }\n\n  return Math.round(discount * 100) / 100;\n}\n\nfunction calculateTax(amount) {\n  return Math.round(amount * TAX_RATE * 100) / 100;\n}\n\nfunction processOrder(order) {\n  const validation = validateOrder(order);\n  if (!validation.valid) {\n    return {\n      success: false,\n      errors: validation.errors\n    };\n  }\n\n  const subtotal = calculateSubtotal(order.items);\n  const discount = calculateDiscount(subtotal, order);\n  const afterDiscount = subtotal - discount;\n  const tax = calculateTax(afterDiscount);\n  const total = Math.round((afterDiscount + tax) * 100) / 100;\n\n  return {\n    success: true,\n    subtotal,\n    discount,\n    tax,\n    total,\n    itemCount: order.items.reduce((sum, item) => sum + item.quantity, 0)\n  };\n}\n\nfunction generateInvoice(order) {\n  const result = processOrder(order);\n\n  if (!result.success) {\n    return `INVALID ORDER:\\n${result.errors.join('\\n')}`;\n  }\n\n  let invoice = '===== INVOICE =====\\n';\n  invoice += `Customer: ${order.customerName || 'Guest'}\\n`;\n  invoice += `Member: ${order.isMember ? 'Yes' : 'No'}\\n`;\n  invoice += '-------------------\\n';\n\n  for (const item of order.items) {\n    const lineTotal = item.price * item.quantity;\n    // QUIRK: item names are truncated to 20 characters in the invoice\n    const displayName = item.name.length > 20\n      ? item.name.substring(0, 17) + '...'\n      : item.name;\n    invoice += `${displayName.padEnd(20)} x${item.quantity}  $${lineTotal.toFixed(2)}\\n`;\n  }\n\n  invoice += '-------------------\\n';\n  invoice += `Subtotal:  $${result.subtotal.toFixed(2)}\\n`;\n\n  if (result.discount > 0) {\n    invoice += `Discount: -$${result.discount.toFixed(2)}\\n`;\n  }\n\n  invoice += `Tax (8%):   $${result.tax.toFixed(2)}\\n`;\n  invoice += `TOTAL:      $${result.total.toFixed(2)}\\n`;\n  invoice += '===================\\n';\n\n  return invoice;\n}\n\nmodule.exports = {\n  validateItem,\n  validateOrder,\n  calculateSubtotal,\n  calculateDiscount,\n  calculateTax,\n  processOrder,\n  generateInvoice\n};\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create a test file for the order processor",
      "type": "file_exists",
      "target": "orderProcessor.test.js",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Test the validateItem function",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "validateItem",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Test the validateOrder function",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "validateOrder",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Test the calculateSubtotal function",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "calculateSubtotal|subtotal",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Test the processOrder function",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "processOrder",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "Test the generateInvoice function",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "generateInvoice|invoice",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "Test discount calculation (bulk and/or member)",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "discount|member|bulk",
      "required": true
    },
    {
      "id": "obj-8",
      "description": "All tests pass against existing code",
      "type": "command_output_contains",
      "command": "cd ~/dojo-workspace/challenge-11-004 && npm test 2>&1",
      "pattern": "pass|ok",
      "required": true
    },
    {
      "id": "obj-9",
      "description": "Create FINDINGS.md documenting questionable behavior",
      "type": "file_exists",
      "target": "FINDINGS.md",
      "required": true
    },
    {
      "id": "obj-10",
      "description": "FINDINGS.md describes a specific behavioral issue",
      "type": "file_contains",
      "target": "FINDINGS.md",
      "pattern": "discount|bug|quirk|questionable|unexpected|issue",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Test invalid order scenarios (missing items, empty array, null order)",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "invalid|empty|null|missing",
      "xpBonus": 40
    },
    {
      "id": "bonus-2",
      "description": "Test the name truncation behavior in generateInvoice",
      "type": "file_contains",
      "target": "orderProcessor.test.js",
      "pattern": "truncat|substring|20|\\.\\.\\.",
      "xpBonus": 40
    },
    {
      "id": "bonus-3",
      "description": "Document the member discount stacking issue in FINDINGS.md",
      "type": "file_contains",
      "target": "FINDINGS.md",
      "pattern": "member.*discount|discount.*member|stack|original.*subtotal|combined",
      "xpBonus": 50
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Start by reading orderProcessor.js carefully. Note the exported functions: validateItem, validateOrder, calculateSubtotal, calculateDiscount, calculateTax, processOrder, generateInvoice. Test the simpler functions first (validateItem, calculateSubtotal, calculateTax) then build up to processOrder and generateInvoice. Look for comments that say QUIRK or BUG -- these hint at questionable behavior to document.",
      "xpCost": 15
    },
    {
      "level": 2,
      "text": "For characterization tests, create test orders and observe what the functions actually return. Key test cases: 1) validateItem with valid item, missing name, negative price, zero quantity. 2) validateOrder with valid order, empty items array, null order. 3) calculateSubtotal with simple items. 4) calculateDiscount with bulk quantity (>=5), with member flag, with both. 5) processOrder for valid and invalid orders. 6) generateInvoice checking the output string format. For FINDINGS.md, look at how member discount interacts with bulk discount -- the member discount is applied to the original subtotal, not the post-bulk-discount amount.",
      "xpCost": 50
    },
    {
      "level": 3,
      "text": "Ask Claude: 'Read orderProcessor.js carefully and write characterization tests in orderProcessor.test.js. Test ALL 7 exported functions. For validateItem: test valid item, missing name, negative price, invalid quantity. For validateOrder: valid order, empty items, null order. For calculateSubtotal: simple totals, multiple items. For calculateDiscount: no discount, bulk discount (quantity >= 5 triggers 10%), member discount (5%), both combined. For processOrder: valid order returns success with subtotal/discount/tax/total, invalid order returns errors. For generateInvoice: check output contains INVOICE header, item lines, totals. Tests must PASS against existing code without modification. Then create FINDINGS.md documenting that the member discount is applied to the original subtotal rather than the already-discounted amount, which gives members a slightly larger discount than intended.'",
      "xpCost": 100
    }
  ],

  "solution": {
    "approach": "Read the legacy code to understand current behavior. Write characterization tests for each exported function that capture what the code actually does (not what it should do). Test happy paths, error paths, and edge cases. Document questionable behaviors in FINDINGS.md.",
    "example": "Write characterization tests for the legacy order processor and document questionable behaviors",
    "alternativeApproaches": [
      "Start with processOrder integration tests and work backward to unit tests",
      "Use generateInvoice as an integration test that exercises the whole pipeline",
      "Focus on the discount calculation since it has the most complex branching"
    ]
  },

  "learningPoints": [
    "Legacy code is defined as code without tests (Michael Feathers)",
    "Characterization tests capture CURRENT behavior, even if it seems wrong",
    "Never change the code before you have tests -- you need a safety net first",
    "Test the public API (exported functions) before internal implementation",
    "Document questionable behaviors separately -- don't fix them during testing",
    "Discrepancies between expected and actual behavior are valuable findings",
    "The Strangler Fig pattern lets you gradually replace legacy code with tested code"
  ],

  "nextChallenge": "11-005"
}