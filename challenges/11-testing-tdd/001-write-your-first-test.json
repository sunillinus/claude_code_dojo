{
  "id": "11-001",
  "module": "testing-tdd",
  "title": "Write Your First Test",
  "description": "Learn why testing matters, how tests are structured, and write comprehensive tests for a utility library using Node.js built-in test runner.",
  "difficulty": "beginner",
  "xpReward": 150,
  "estimatedMinutes": 15,
  "skills": ["testing", "assertions", "test-structure", "edge-cases"],

  "setup": {
    "workingDir": "~/dojo-workspace/challenge-11-001",
    "initialFiles": [
      {
        "path": "README.md",
        "content": "# Challenge: Write Your First Test\n\nLearn the fundamentals of testing and write comprehensive tests for a math\nutility library using Node.js built-in test runner.\n\n## Why We Test\n\nTesting is not optional busy-work. It is a fundamental engineering practice\nthat serves four critical purposes:\n\n1. **Catch bugs early** - Find problems during development, not production.\n   A bug caught during testing costs 10x less to fix than one found in prod.\n2. **Document behavior** - Tests are executable documentation. They show\n   exactly how your code is supposed to work, with real examples.\n3. **Enable refactoring** - Want to rewrite a function for performance?\n   If tests pass after your change, you know you didn't break anything.\n4. **Prevent regressions** - Once you fix a bug, write a test for it.\n   That bug can never come back silently.\n\n## Test Structure: Arrange, Act, Assert\n\nEvery good test follows the AAA pattern:\n\n```javascript\ntest('clamp should restrict value to range', () => {\n  // ARRANGE - set up test data\n  const value = 15;\n  const min = 0;\n  const max = 10;\n\n  // ACT - execute the code under test\n  const result = clamp(value, min, max);\n\n  // ASSERT - verify the result\n  assert.strictEqual(result, 10);\n});\n```\n\n**Arrange**: Create the inputs and expected outputs you need.\n**Act**: Call the function or method you are testing.\n**Assert**: Check that the actual result matches what you expected.\n\n## Node.js Built-in Test Runner\n\nSince Node.js v18, there is a built-in test runner. No need to install\njest, mocha, or any other framework. Here is how it works:\n\n```javascript\nconst { test, describe } = require('node:test');\nconst assert = require('node:assert');\n\n// A single test\ntest('adds two numbers', () => {\n  assert.strictEqual(1 + 1, 2);\n});\n\n// Grouped tests using describe\ndescribe('Math operations', () => {\n  test('addition', () => {\n    assert.strictEqual(2 + 3, 5);\n  });\n\n  test('subtraction', () => {\n    assert.strictEqual(5 - 3, 2);\n  });\n});\n```\n\nRun tests with: `node --test` or `npm test`\n\n## Key Assertion Methods\n\n| Method | Purpose | Example |\n|--------|---------|--------|\n| `assert.strictEqual(a, b)` | Exact equality (===) | `assert.strictEqual(add(1,2), 3)` |\n| `assert.deepStrictEqual(a, b)` | Deep object/array equality | `assert.deepStrictEqual([1,2], [1,2])` |\n| `assert.ok(value)` | Value is truthy | `assert.ok(isPrime(7))` |\n| `assert.throws(fn)` | Function throws an error | `assert.throws(() => factorial(-1))` |\n| `assert.throws(fn, Error)` | Throws specific error type | `assert.throws(() => fn(), TypeError)` |\n\n## What Makes a Good Test\n\nGOOD tests:\n- **Test one thing** - each test verifies a single behavior\n- **Have descriptive names** - `'average returns 0 for empty array'` not `'test 3'`\n- **Are independent** - no test depends on another test running first\n- **Are deterministic** - same input always gives same output (no randomness)\n- **Cover edge cases** - empty inputs, zero, negative numbers, boundaries\n\nBAD tests:\n- Test implementation details (HOW it works instead of WHAT it returns)\n- Are brittle (break when you make valid changes to the code)\n- Test multiple behaviors in one test case\n- Depend on external state or other tests running first\n\n## Test File Naming Convention\n\nFor a file named `mathUtils.js`, the test file should be named:\n- `mathUtils.test.js` (most common)\n- `mathUtils.spec.js` (also accepted)\n\n## What Types of Test Cases Should You Write?\n\nFor each function, consider these categories:\n\n1. **Normal/Happy path** - typical valid inputs\n2. **Edge cases** - boundary values, empty inputs, zero, one element\n3. **Error cases** - invalid inputs that should throw or return error values\n4. **Special values** - negative numbers, very large numbers, special mathematical values\n\nExample for an `average(numbers)` function:\n- Normal: `average([1, 2, 3])` returns `2`\n- Edge: `average([5])` returns `5` (single element)\n- Edge: `average([])` returns `0` or throws (empty array)\n- Normal: `average([1.5, 2.5])` returns `2` (decimals)\n\n## Your Task\n\nThe file `mathUtils.js` contains 5 utility functions with NO tests.\nYour job is to write comprehensive tests for ALL of them.\n\nEach function needs at least 3 test cases covering:\n- Normal input (the function works as expected)\n- Edge cases (boundary values, special inputs)\n- Error cases (invalid inputs, if applicable)\n\nAim for 15-20 test cases total across all 5 functions.\n\n## Objectives\n1. Create `mathUtils.test.js` with tests for all 5 functions\n2. Use `describe()` blocks to group tests by function\n3. Include edge case tests (empty array, 0, 1, negative numbers)\n4. Include error case tests (using `assert.throws`)\n5. All tests should pass when you run `npm test`\n"
      },
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"first-test-challenge\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"test\": \"node --test\"\n  }\n}\n"
      },
      {
        "path": "mathUtils.js",
        "content": "/**\n * Clamps a value between a minimum and maximum.\n * @param {number} value - The value to clamp\n * @param {number} min - The minimum boundary\n * @param {number} max - The maximum boundary\n * @returns {number} The clamped value\n */\nfunction clamp(value, min, max) {\n  if (min > max) throw new Error('min must not be greater than max');\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Calculates the average of an array of numbers.\n * @param {number[]} numbers - Array of numbers\n * @returns {number} The arithmetic mean, or 0 for empty array\n */\nfunction average(numbers) {\n  if (numbers.length === 0) return 0;\n  const sum = numbers.reduce((acc, n) => acc + n, 0);\n  return sum / numbers.length;\n}\n\n/**\n * Checks if a number is prime.\n * @param {number} n - The number to check\n * @returns {boolean} True if n is prime\n */\nfunction isPrime(n) {\n  if (n < 2) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    if (n % i === 0) return false;\n  }\n  return true;\n}\n\n/**\n * Calculates the factorial of a non-negative integer.\n * @param {number} n - A non-negative integer\n * @returns {number} n!\n * @throws {Error} If n is negative\n */\nfunction factorial(n) {\n  if (n < 0) throw new Error('Factorial is not defined for negative numbers');\n  if (n === 0 || n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\n/**\n * Returns the nth Fibonacci number (0-indexed).\n * fibonacci(0) = 0, fibonacci(1) = 1, fibonacci(2) = 1, ...\n * @param {number} n - The index (non-negative integer)\n * @returns {number} The nth Fibonacci number\n * @throws {Error} If n is negative\n */\nfunction fibonacci(n) {\n  if (n < 0) throw new Error('Fibonacci is not defined for negative indices');\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  let a = 0, b = 1;\n  for (let i = 2; i <= n; i++) {\n    [a, b] = [b, a + b];\n  }\n  return b;\n}\n\nmodule.exports = { clamp, average, isPrime, factorial, fibonacci };\n"
      }
    ],
    "cleanBefore": true
  },

  "objectives": [
    {
      "id": "obj-1",
      "description": "Create a test file named mathUtils.test.js",
      "type": "file_exists",
      "target": "mathUtils.test.js",
      "required": true
    },
    {
      "id": "obj-2",
      "description": "Import node:test and node:assert modules",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "require\\(['\"]node:test['\"]\\)",
      "required": true
    },
    {
      "id": "obj-3",
      "description": "Write tests for the clamp function",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "clamp",
      "required": true
    },
    {
      "id": "obj-4",
      "description": "Write tests for the average function",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "average",
      "required": true
    },
    {
      "id": "obj-5",
      "description": "Write tests for the isPrime function",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "isPrime",
      "required": true
    },
    {
      "id": "obj-6",
      "description": "Write tests for the factorial function",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "factorial",
      "required": true
    },
    {
      "id": "obj-7",
      "description": "Write tests for the fibonacci function",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "fibonacci",
      "required": true
    },
    {
      "id": "obj-8",
      "description": "Test edge case: empty array for average",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "\\[\\s*\\]",
      "required": true
    },
    {
      "id": "obj-9",
      "description": "Test error cases using assert.throws",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "assert\\.throws",
      "required": true
    },
    {
      "id": "obj-10",
      "description": "All tests pass",
      "type": "command_output_contains",
      "command": "cd ~/dojo-workspace/challenge-11-001 && npm test 2>&1",
      "pattern": "pass|ok",
      "required": true
    }
  ],

  "bonusObjectives": [
    {
      "id": "bonus-1",
      "description": "Use describe() blocks to group tests by function",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "describe",
      "xpBonus": 25
    },
    {
      "id": "bonus-2",
      "description": "Test fibonacci for 0 and 1 (base cases)",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "fibonacci.*0|fibonacci.*1",
      "xpBonus": 25
    },
    {
      "id": "bonus-3",
      "description": "Test that factorial throws for negative input",
      "type": "file_contains",
      "target": "mathUtils.test.js",
      "pattern": "factorial.*-|negative.*factorial",
      "xpBonus": 25
    }
  ],

  "hints": [
    {
      "level": 1,
      "text": "Start by importing node:test and node:assert. Then import all 5 functions from mathUtils.js. Create a describe block for each function, and write 3-5 test() calls inside each block. Think about: what is the normal case? What happens at the boundaries (0, 1, empty array)? What inputs should cause an error?",
      "xpCost": 10
    },
    {
      "level": 2,
      "text": "For edge cases to consider: clamp - what if value equals min or max? What if min > max? average - what about an empty array? A single element? isPrime - test 0, 1, 2, a large prime like 97, an even composite like 4. factorial - test 0 (should be 1), test negative (should throw). fibonacci - test 0 (returns 0), test 1 (returns 1), test a known value like fibonacci(10) = 55.",
      "xpCost": 30
    },
    {
      "level": 3,
      "text": "Ask Claude: 'Create mathUtils.test.js with comprehensive tests for all 5 functions in mathUtils.js (clamp, average, isPrime, factorial, fibonacci). Use node:test with describe blocks. Include normal cases, edge cases (empty array, 0, 1), and error cases (negative factorial, negative fibonacci, min > max for clamp). Use assert.strictEqual for values and assert.throws for error cases. Aim for at least 3 tests per function.'",
      "xpCost": 60
    }
  ],

  "solution": {
    "approach": "Create mathUtils.test.js importing node:test and node:assert. Group tests with describe() blocks. For each function, write tests covering normal inputs, edge cases, and error conditions. Use assert.strictEqual for value checks, assert.ok for boolean checks, and assert.throws for error cases.",
    "example": "Write comprehensive tests for all 5 math utility functions using Node.js built-in test runner",
    "alternativeApproaches": [
      "Write all tests flat without describe blocks (still valid, less organized)",
      "Use assert.ok(isPrime(7)) instead of assert.strictEqual(isPrime(7), true)",
      "Test functions in a different order or grouping"
    ]
  },

  "learningPoints": [
    "Tests follow the Arrange-Act-Assert pattern: set up data, call the function, verify the result",
    "Node.js has a built-in test runner (node:test) - no external dependencies needed",
    "Good tests cover normal cases, edge cases, and error cases for each function",
    "assert.strictEqual checks exact equality, assert.throws verifies error conditions",
    "describe() blocks group related tests together for better organization and readability",
    "Test file naming convention: mathUtils.js -> mathUtils.test.js"
  ],

  "nextChallenge": "11-002"
}